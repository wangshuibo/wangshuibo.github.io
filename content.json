[{"title":"七种基本排序算法的实现和总结","date":"2017-12-10T08:33:18.180Z","path":"2017/12/10/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. 一、冒泡排序每次比较两个相邻的元素，如果它们的顺序错误就把它们交换过来。1234567for (int i = 0; i &lt; arr.length; i++) &#123; for (int j = arr.length - 1; j &gt; i; j--) &#123; if (arr[j] &lt; arr[j - 1]) &#123; SortUtil.swap(arr, j, j - 1); &#125; &#125;&#125; 二、选择排序不断地选择剩余元素中的最小者123456789for (int i = 0; i &lt; arr.length; i++) &#123; int minIndex = i; for (int j = i + 1; j &lt; arr.length; j++) &#123; if (arr[j] &lt; arr[minIndex]) &#123; minIndex = j; &#125; &#125; SortUtil.swap(arr, minIndex, i);&#125; 三、插入排序插入排序的工作原理是，对于每个未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。12345678for (int i = 1; i &lt; arr.length; i++) &#123; int temp = arr[i]; int j; for (j = i; j &gt; 0 &amp;&amp; (arr[j - 1] &gt; temp); j--) &#123; arr[j] = arr[j -1]; &#125; arr[j] = temp;&#125; 四、归并排序将长度为n的记录不断划分，划分到长度为1时，再两两合并，依次递归。主要是利用分治法来处理。123456789101112131415161718192021222324252627282930313233@Overridepublic int[] sort(int[] arr) &#123; mergeSort(arr, 0, arr.length - 1); return arr;&#125;private void mergeSort(int[] array, int start, int end) &#123; if (start &gt;= end) return; int middle = (start + end) / 2; mergeSort(array, start, middle); mergeSort(array, middle + 1, end); merge(array, start, middle, end);&#125;private void merge(int[] array, int start, int middle, int end) &#123; int[] aux = new int[end - start + 1]; System.arraycopy(array, start, aux, 0, end - start + 1); int left = start; int right = middle + 1; for (int k = start; k &lt;= end; k++) &#123; if (left &gt; middle) &#123; array[k] = aux[right - start]; right++; &#125; else if (right &gt; end) &#123; array[k] = aux[left - start]; left++; &#125; else if (aux[left - start] &gt; aux[right - start]) &#123; array[k] = aux[right - start]; right++; &#125; else &#123; array[k] = aux[left - start]; left++; &#125; &#125;&#125; 五、堆排序堆排序就是利用堆进行排序的方法.基本思想是:将待排序的序列构造成一个大顶堆.此时,整个序列的最大值就是堆顶的根结点.将它移走(其实就是将其与堆数组的末尾元素交换, 此时末尾元素就是最大值),然后将剩余的n-1个序列重新构造成一个堆,这样就会得到n个元素的次大值.如此反复执行,便能得到一个有序序列了。 12345678910111213141516171819202122232425262728public int[] sort(int[] arr) &#123; int len = arr.length - 1; for (int i = len / 2 - 1; i &gt;= 0; i--) &#123; headAdjust(arr, i, len); &#125; while (len &gt;= 0) &#123; SortUtil.swap(arr, 0, len--); headAdjust(arr, 0, len); &#125; return arr;&#125;private void headAdjust(int[] arr, int parent, int len) &#123; int leftChild, rightChild, maxChild; while ((leftChild = 2 * parent + 1) &lt;= len) &#123; rightChild = leftChild + 1; maxChild = leftChild; // 将maxChild指向左右子节点中的较大者 if (maxChild &lt; len &amp;&amp; (arr[leftChild] &lt; arr[rightChild])) &#123; maxChild++; &#125; if (arr[parent] &lt; arr[maxChild]) &#123; SortUtil.swap(arr, parent, maxChild); parent = maxChild; &#125; else &#123; break; &#125; &#125;&#125; 六、希尔排序先将整个待排元素序列分割成若干子序列（由相隔某个“增量”的元素组成的）分别进行直接插入排序，然后依次缩减增量再进行排序，待整个序列中的元素基本有序（增量足够小）时，再对全体元素进行一次直接插入排序（增量为1）。其时间复杂度为O( n^3/2 ),要好于直接插入排序的O(n^2)12345678910111213int gap = arr.length / 2;while (gap &gt;= 1) &#123; for (int i = gap; i &lt; arr.length; i++) &#123; int temp = arr[i]; int j = i - gap; while (j &gt;= 0 &amp;&amp; arr[j] &gt; temp) &#123; arr[j + gap] = arr[j]; j -= gap; &#125; arr[j + gap] = temp; &#125; gap /= 2;&#125; 七、快速排序通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。12345678910111213141516171819private void quickSort(int[] arr, int left, int right) &#123; if (left &gt;= right) return; int i = left, j = right, temp = arr[left]; while (i &lt; j) &#123; while (i &lt; j &amp;&amp; arr[j] &gt;= temp) &#123; j--; &#125; while (i &lt; j &amp;&amp; arr[i] &lt;= temp) &#123; i++; &#125; if (i &lt; j) &#123; SortUtil.swap(arr, i, j); &#125; &#125; arr[left] = arr[i]; arr[i] = temp; quickSort(arr, left, i - 1); quickSort(arr, i + 1, right);&#125;","tags":[{"name":"排序","slug":"排序","permalink":"http://yoursite.com/tags/排序/"}]}]