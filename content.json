[{"title":"Android Activity事件分发机制","date":"2018-05-27T07:51:53.000Z","path":"2018/05/27/Android-Activity事件分发机制/","text":"前言 当用户触摸屏幕时（View 或 ViewGroup派生的控件），将产生点击事件（Touch事件） Touch事件的相关细节（发生触摸的位置、时间等）被封装成MotionEvent对象 事件类型(4种) 事件类型 具体动作 MotionEvent.ACTION_DOWN 按下View（所有事件的开始) MotionEvent.ACTION_UPMO 抬起View（与DOWN对应) MotionEvent.ACTION_MOVE 滑动View MotionEvent.ACTION_CANCEL 结束事件（非人为原因) 事件在哪些对象之间进行传递 Activity—&gt;ViewGroup—&gt;View 核心方法 dispatchTouchEvent()—&gt;onInterceptTouchEvent()(备注:这个方法只有ViewGroup有,View和Activity没有)—&gt;onTouchEvent() 源码分析 1234567891011121314151617181920212223242526272829303132333435Activity 源码分析/** * Called to process touch screen events. You can override this to * intercept all touch screen events before they are dispatched to the * window. Be sure to call this implementation for touch screen events * that should be handled normally. * * @param ev The touch screen event. * * @return boolean Return true if this event was consumed. */ public boolean dispatchTouchEvent(MotionEvent ev) &#123; // 一般事件列开始都是DOWN事件 = 按下事件，故此处基本是true if (ev.getAction() == MotionEvent.ACTION_DOWN) &#123; onUserInteraction(); &#125; if (getWindow().superDispatchTouchEvent(ev)) &#123; return true; // 若getWindow().superDispatchTouchEvent(ev)的返回true // 则Activity.dispatchTouchEvent（）就返回true，则方法结束。即 ：该点击事件停止往下传递 &amp; 事件传递过程结束 // 否则：继续往下调用Activity.onTouchEvent &#125; return onTouchEvent(ev); &#125;/** * 分析1：onUserInteraction() * 作用：实现屏保功能 * 注： * a. 该方法为空方法 * b. 当此activity在栈顶时，触屏点击按home，back，menu键等都会触发此方法 */ public void onUserInteraction() &#123; &#125; 接着我们继续看 superDispatchTouchEvent(ev) 方法 这里我在说下窗口机制:主要是由Activity—&gt;PhoneWindow—&gt;DecorView—&gt;ContentView，也就是PhoneWindow通过继承Window抽象类,然后触发这个方法，接着调用DecorView方法,将当前手势传下去，因为DecorView是继承FrameLayout。由于FrameLayout的父类是ViewGroup，DecorView间接=ViewGroup(下一章节会说到),放松一下,图片走起,哈哈哈 1234567891011121314/** * 分析2：getWindow().superDispatchTouchEvent(ev) * 说明： * a. getWindow() = 获取Window类的对象 * b. Window类是抽象类，其唯一实现类 = PhoneWindow类；即此处的Window类对象 = PhoneWindow类对象 * c. Window类的superDispatchTouchEvent() = 1个抽象方法，由子类PhoneWindow类实现 */ @Override public boolean superDispatchTouchEvent(MotionEvent event) &#123; return mDecor.superDispatchTouchEvent(event); // mDecor = 顶层View（DecorView）的实例对象 &#125; 流程图","comments":true,"tags":[{"name":"Android Activity事件分发机制","slug":"Android-Activity事件分发机制","permalink":"/tags/Android-Activity事件分发机制/"}]},{"title":"retrofit源码分析","date":"2018-05-06T04:01:29.309Z","path":"2018/05/06/retrofit/","text":"导言retrofit的最大特点就是解耦，要解耦就需要大量的设计模式。假如一点设计模式都不懂的人，可能很难看懂retrofit。~_~ 不要着急, 先上图，压压惊。 首先呢，还是看一下流程图。（如果哪有遗漏，可以私发给我 QQ号:203911607） 主体下面讲解一下主流程: 1.创建一个接口进行HTTP请求描述；2.使用Retrofit.Builder构建模式构造出一个Retrofit实例；3.调用retrofit.create()方法获取请求接口实例；4.由请求接口实例获取到Call对象；进行网络请求（同步/异步）接下来，我们就按照以上正常的网络请求顺序来对Retrofit源码进行解析。 创建一个接口进行HTTP请求描述 public interface ApiService { @GET(“users/{user}/gg”) Call bean(@Path(“user”) String user);}这里主要做的就是采用注解的方式进行HTTP描述，后面在第4步由请求接口实例获取到Call对象时进行反射提取注解内容进行HTTP请求构造（如果开启了预先加载解析（validateEagerly=true），那么在第3步调用retrofit.create()方法获取请求接口实例的时候就会进行注解解析），具体解析方法参考后续分析。 使用Retrofit.Builder构建模式构造出一个Retrofit实例123Retrofit retrofit = new Retrofit.Builder() .baseUrl(\"https://wangshuipo.top/\") .build(); 那我们就先来看下Retrofit.Builder部分源码: 1234567891011121314151617181920/** * Build a new &#123;@link Retrofit&#125;. * Calling &#123;@link #baseUrl&#125; is required before calling &#123;@link #build()&#125;. All other methods * are optional. */ public static final class Builder &#123; private final Platform platform; //callFactory通过newCall(Request request)方法，返回一个okhttp3.Call对象，以便让我们进行实际的HTTP请求 //也就是说callFactory是我们用来生成一个客户端HTTP请求工厂实例 private @Nullable okhttp3.Call.Factory callFactory; private HttpUrl baseUrl; //converterFactories生产Converter&lt;F, T&gt;，用于将HTTP返回结果F类型转换为T类型，或将HTTP请求类型F转换为T。 private final List&lt;Converter.Factory&gt; converterFactories = new ArrayList&lt;&gt;(); //adapterFactories生产 CallAdapter&lt;R, T&gt;，用于将retrofit2.Call&lt;R&gt;网络请求类型转换为T类型：T adapt(Call&lt;R&gt; var1); private final List&lt;CallAdapter.Factory&gt; adapterFactories = new ArrayList&lt;&gt;(); private @Nullable Executor callbackExecutor; private boolean validateEagerly; ···&#125; 从Retrofit.Builder的注释中，我们可以看到，在调用Retrofit.Builder.build()之前，除了baseUrl()是必须配置的以外，其他的内容都是可选配置。这里要对两个类型做下讲解，因为笔者在刚分析Retrofit源码时，被这两个类型的概念弄得头晕眼胀，好在一顿分析后，终于有了一点眉目，这两个类型就是：Converter和CallAdapter。Converter：数据转换器，用来将HTTP请求返回结果由F类型转换为T类型，或者将HTTP请求类型F转换为T123456789public interface Converter&lt;F, T&gt; &#123; T convert(F value) throws IOException; ···&#125;//举例：new Retrofit.Builder() .baseUrl(\"https://wangshuipo.top/\") .addConverterFactory(GsonConverterFactory.create()) .build(); 上面配置了ConverterFactory为GsonConverterFactory，那么当HTTP请求结果返回时，就会由GsonConverterFactory产生的Converter，假设为Converter","comments":true,"tags":[{"name":"retrofit源码分析","slug":"retrofit源码分析","permalink":"/tags/retrofit源码分析/"}]},{"title":"git提交基本命令","date":"2018-04-24T08:03:56.948Z","path":"2018/04/24/gitStyle/","text":"基本命令:1.ls -a 表示使用lunix命令查看文件夹下的文件。 2.git init 表示初始化一个空的git仓库。 3.git status 表示默认生成的仓库里该文件夹里面的文件没有追踪，这个命令可以查看当前状态。 4.git add 文件名 表示添加到暂存区，追踪。 5.git commit -m &apos;可以添加描述&apos; 表示提交文件。 6.git log 表示查看提交信息。 7.git add . 表示可以添加全部文件。 8.git commit -am &apos;可以添加描述&apos; 表示添加并提交文件。 9.git log --oneline 表示只查看描述信息。 git的三层结构1.working directory 工作区 2.staging index 暂存区 3.git directory(Repository)版本库 git中文件四种状态1.untracked:未追踪 2.Modified:表示工作区修改了某个文件但是还没有添加到暂存区 3.Stage:表示把工作区修改的文件添加到暂存区但是没有提交到版本库 4.Committed:表示数据被安全的存储在本地仓库中 git撤销操作1.git commit --amend 撤销上一次提交，并将暂存区的文件重新提交。(注意跳出是先按Esc，然后输入输入:wq再按Enter键) 2.git checkout -- filename 拉取暂存区的文件并将其替换工作区的文件，注意与git checkout branchname区别 3.git reset HEAD -- filename 拉取最近一次提交的版本库中的这个文件到暂存区，该操作不影响工作区。(可以在git log 中选择其中的一个版本号替换HEAD,这么做可以拉回上一次提交的样式。具体写法git reset 选择想要替换回来的一次版本号 filename ) 4.git reset --options 版本号{options可以替换--hard --mixed --soft } git文件删除1.git rm --filename {1.删除工作区及暂存区中的改文件相当于删除文件后执行 git add 2.git rm --cached filename 在不小心将不需要追踪的文件添加到暂存区，想要删除暂存的文件但不想删除工作区的文件很有用(应用场景.gitignore.git远程仓库) 3.git rm -f filename 当工作区或者暂存区文件修改了(防止把修改误删除了) 4.glob模式--星号(*)匹配零个或多个任意字符 --[abc] 匹配任何一个列在方括号中的字符--问号(?)只匹配一个任意字符 --[0-9]、[a-z]匹配范围 } 2.git mv --filename 相当于 {1.mv oldname newname 2.git rm oldname 3.git add newname } git分支1.git 分支的创建、修改、切换、删除{1.git branch 查看分支 2.git branch branchname创建分支 3.git branch -m oldname newname 修改分支名称 4.git checkout [-b] branchname 如果加上-b命令的意思是创建该分支并且切换分支,反之只是切换分支 5.git branch -D branchname删除分支 } 2. git 分支合并 2-1.分值的指南--HEAD指向当前工作的分支--再切换分支时指向新的分支 2-2.git diff{1.git diff 比较工作区与暂存区文件的差异 2.git diff --staged 比较暂存区与版本库的文件差异 3.git diff 版本号 版本号 比较分支内两个版本的差异 4.git diff 分支 分支 比较两个分支的最新提交版本的差异 } 2-3.git merge branchname 合并之前需要先切换到master分支--快速合并和冲突合并 3.存储变更 3-1.git stash 3-2.git stash list 3-3.git stash apply stash@num git stash apply 后面不加名字则应用最近一次存储信息 3-4.git stash drop stash@num git stash apply 只是运用存储信息，并不删除他，drop命令可以删除它 git 远程仓库1.github上的仓库{1.创建仓库 2.clone仓库到本地 3.本地push到仓库 4.pull代码到本地 5.ignoring files } 2.远程服务器上的仓库{1.用taskmanager来演示 2.git init --bare 3.git remote add name path 4.git remote rm name 5.git remote rename oldname newname 6.git fetch } 3.Git ssh免密登录{1.首先要配置username和邮箱 git config --global user.name yinlijun git config user.email aaa@aaa.com如果配置了就不要配置 ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 2.ssh-copy-id user@host 将本机的公钥复制到远程服务器的authorized_keys文件中 3.如果不是自己的服务器可以将本地公钥发给服务器管理员添加在authorized_keys文件后面 4. } Git帮助文档的使用1.git help 2.git help command 3.官方地址---http://git-scm.com/docs http://www.wangshuibo.github.io","comments":true,"tags":[{"name":"git命令","slug":"git命令","permalink":"/tags/git命令/"}]},{"title":"七种基本排序算法的实现和总结","date":"2017-12-10T08:33:18.179Z","path":"2017/12/10/px/","text":"1、冒泡排序123456789101112 原理：每次比较两个相邻的元素，如果它们的顺序错误就把它们交换过来。 步骤：1.1 比较相邻的元素。如果倒数第一个比倒数第二个小，就交换他们两个。 1.2 对第0个到第n-1个数据做同样的工作。这时，最小的数就“浮”到了数组最开始的位置上。 1.3 针对所有的元素重复以上的步骤，除了第一个。 1.4 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。for (int i = 0; i &lt; arr.length; i++) &#123; for (int j = arr.length - 1; j &gt; i; j--) &#123; if (arr[j] &lt; arr[j - 1]) &#123; SortUtil.swap(arr, j, j - 1); &#125; &#125;&#125; 2、选择排序12345678910111213 原理：不断地选择剩余元素中的最小者 步骤：2.1 找到数组中最小元素的下标，将第一个元素与最小元素下标的数进行交换。 2.2 在剩下的元素中找到最小元素下标并将其与数组第二个元素交换，直至整个数组排序。for (int i = 0; i &lt; arr.length; i++) &#123; int minIndex = i; for (int j = i + 1; j &lt; arr.length; j++) &#123; if (arr[j] &lt; arr[minIndex]) &#123; minIndex = j; &#125; &#125; SortUtil.swap(arr, minIndex, i);&#125; 3、插入排序123456789101112131415 原理：插入排序的工作原理是，对于每个未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。 步骤：3.1 从第一个元素开始，该元素可以认为已经被排序 3.2 取出下一个元素，在已经排序的元素序列中从后向前扫描 3.3 如果被扫描的元素（已排序）大于新元素，将该元素后移一位 3.4 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置 3.5 将新元素插入到该位置后 3.6 重复步骤2~5for (int i = 1; i &lt; arr.length; i++) &#123; int temp = arr[i]; int j; for (j = i; j &gt; 0 &amp;&amp; (arr[j - 1] &gt; temp); j--) &#123; arr[j] = arr[j -1]; &#125; arr[j] = temp;&#125; 4、归并排序12345678910111213141516171819202122232425262728293031323334 原理：将长度为n的记录不断划分，划分到长度为1时，再两两合并，依次递归。主要是利用分治法来处理。@Overridepublic int[] sort(int[] arr) &#123; mergeSort(arr, 0, arr.length - 1); return arr;&#125;private void mergeSort(int[] array, int start, int end) &#123; if (start &gt;= end) return; int middle = (start + end) / 2; mergeSort(array, start, middle); mergeSort(array, middle + 1, end); merge(array, start, middle, end);&#125;private void merge(int[] array, int start, int middle, int end) &#123; int[] aux = new int[end - start + 1]; System.arraycopy(array, start, aux, 0, end - start + 1); int left = start; int right = middle + 1; for (int k = start; k &lt;= end; k++) &#123; if (left &gt; middle) &#123; array[k] = aux[right - start]; right++; &#125; else if (right &gt; end) &#123; array[k] = aux[left - start]; left++; &#125; else if (aux[left - start] &gt; aux[right - start]) &#123; array[k] = aux[right - start]; right++; &#125; else &#123; array[k] = aux[left - start]; left++; &#125; &#125;&#125; 5、堆排序12345678910111213141516171819202122232425262728293031 原理：堆排序就是利用堆进行排序的方法.基本思想是:将待排序的序列构造成一个大顶堆.此时,整个序列的最大值就是堆顶的根结点.将它移走(其实就是将其与堆数组的末尾元素交换,此时末尾元素就是最大值),然后将剩余的n-1个序列重新构造成一个堆,这样就会得到n个元素的次大值.如此反复执行,便能得到一个有序序列了。 步骤：5.1 构造最大堆（Build_Max_Heap）：若数组下标范围为0~n，考虑到单独一个元素是大根堆，则从下标n/2开始的元素均为大根堆。于是只要从n/2-1开始，向前依次构造大根堆，这样就能保证，构造到某个节点时，它的左右子树都已经是大根堆。5.2 堆排序（HeapSort）：由于堆是用数组模拟的。得到一个大根堆后，数组内部并不是有序的。因此需要将堆化数组有序化。思想是移除根节点，并做最大堆调整的递归运算。第一次将heap[0]与heap[n-1]交换，再对heap[0...n-2]做最大堆调整。第二次将heap[0]与heap[n-2]交换，再对heap[0...n-3]做最大堆调整。重复该操作直至heap[0]和heap[1]交换。由于每次都是将最大的数并入到后面的有序区间，故操作完后整个数组就是有序的了。 5.3 最大堆调整（Max_Heapify）：该方法是提供给上述两个过程调用的。目的是将堆的末端子节点作调整，使得子节点永远小于父节点 。public int[] sort(int[] arr) &#123; int len = arr.length - 1; for (int i = len / 2 - 1; i &gt;= 0; i--) &#123; headAdjust(arr, i, len); &#125; while (len &gt;= 0) &#123; SortUtil.swap(arr, 0, len--); headAdjust(arr, 0, len); &#125; return arr;&#125;private void headAdjust(int[] arr, int parent, int len) &#123; int leftChild, rightChild, maxChild; while ((leftChild = 2 * parent + 1) &lt;= len) &#123; rightChild = leftChild + 1; maxChild = leftChild; // 将maxChild指向左右子节点中的较大者 if (maxChild &lt; len &amp;&amp; (arr[leftChild] &lt; arr[rightChild])) &#123; maxChild++; &#125; if (arr[parent] &lt; arr[maxChild]) &#123; SortUtil.swap(arr, parent, maxChild); parent = maxChild; &#125; else &#123; break; &#125; &#125;&#125; 6、希尔排序123456789101112131415 原理：先将整个待排元素序列分割成若干子序列（由相隔某个“增量”的元素组成的）分别进行直接插入排序，然后依次缩减增量再进行排序，待整个序列中的元素基本有序（增量足够小）时，再对全体元素进行一次直接插入排序（增量为1）。其时间复杂度为O( n^3/2 ),要好于直接插入排序的O(n^2)int gap = arr.length / 2;while (gap &gt;= 1) &#123; for (int i = gap; i &lt; arr.length; i++) &#123; int temp = arr[i]; int j = i - gap; while (j &gt;= 0 &amp;&amp; arr[j] &gt; temp) &#123; arr[j + gap] = arr[j]; j -= gap; &#125; arr[j + gap] = temp; &#125; gap /= 2;&#125; 7、快速排序1234567891011121314151617181920212223 原理：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。 步骤：7.1 从数列中挑出一个元素作为基准数。 7.2 分区过程，将比基准数大的放到右边，小于或等于它的数都放到左边。 7.3 再对左右区间递归执行第二步，直至各区间只有一个数。private void quickSort(int[] arr, int left, int right) &#123; if (left &gt;= right) return; int i = left, j = right, temp = arr[left]; while (i &lt; j) &#123; while (i &lt; j &amp;&amp; arr[j] &gt;= temp) &#123; j--; &#125; while (i &lt; j &amp;&amp; arr[i] &lt;= temp) &#123; i++; &#125; if (i &lt; j) &#123; SortUtil.swap(arr, i, j); &#125; &#125; arr[left] = arr[i]; arr[i] = temp; quickSort(arr, left, i - 1); quickSort(arr, i + 1, right);&#125;","comments":true,"tags":[{"name":"排序","slug":"排序","permalink":"/tags/排序/"}]}]