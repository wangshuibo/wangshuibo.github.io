[{"title":"七种基本排序算法的实现和总结","date":"2017-12-10T08:33:18.180Z","path":"2017/12/10/hello-world/","text":"1、冒泡排序123456789101112 原理：每次比较两个相邻的元素，如果它们的顺序错误就把它们交换过来。 步骤：1.1 比较相邻的元素。如果倒数第一个比倒数第二个小，就交换他们两个。 1.2 对第0个到第n-1个数据做同样的工作。这时，最小的数就“浮”到了数组最开始的位置上。 1.3 针对所有的元素重复以上的步骤，除了第一个。 1.4 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。for (int i = 0; i &lt; arr.length; i++) &#123; for (int j = arr.length - 1; j &gt; i; j--) &#123; if (arr[j] &lt; arr[j - 1]) &#123; SortUtil.swap(arr, j, j - 1); &#125; &#125;&#125; 2、选择排序 123456789101112 原理：不断地选择剩余元素中的最小者 步骤：2.1 找到数组中最小元素的下标，将第一个元素与最小元素下标的数进行交换。 2.2 在剩下的元素中找到最小元素下标并将其与数组第二个元素交换，直至整个数组排序。for (int i = 0; i &lt; arr.length; i++) &#123; int minIndex = i; for (int j = i + 1; j &lt; arr.length; j++) &#123; if (arr[j] &lt; arr[minIndex]) &#123; minIndex = j; &#125; &#125; SortUtil.swap(arr, minIndex, i);&#125; 3、插入排序123456789101112131415 原理：插入排序的工作原理是，对于每个未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。 步骤：3.1 从第一个元素开始，该元素可以认为已经被排序 3.2 取出下一个元素，在已经排序的元素序列中从后向前扫描 3.3 如果被扫描的元素（已排序）大于新元素，将该元素后移一位 3.4 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置 3.5 将新元素插入到该位置后 3.6 重复步骤2~5for (int i = 1; i &lt; arr.length; i++) &#123; int temp = arr[i]; int j; for (j = i; j &gt; 0 &amp;&amp; (arr[j - 1] &gt; temp); j--) &#123; arr[j] = arr[j -1]; &#125; arr[j] = temp;&#125; 4、归并排序12345678910111213141516171819202122232425262728293031323334 原理：将长度为n的记录不断划分，划分到长度为1时，再两两合并，依次递归。主要是利用分治法来处理。@Overridepublic int[] sort(int[] arr) &#123; mergeSort(arr, 0, arr.length - 1); return arr;&#125;private void mergeSort(int[] array, int start, int end) &#123; if (start &gt;= end) return; int middle = (start + end) / 2; mergeSort(array, start, middle); mergeSort(array, middle + 1, end); merge(array, start, middle, end);&#125;private void merge(int[] array, int start, int middle, int end) &#123; int[] aux = new int[end - start + 1]; System.arraycopy(array, start, aux, 0, end - start + 1); int left = start; int right = middle + 1; for (int k = start; k &lt;= end; k++) &#123; if (left &gt; middle) &#123; array[k] = aux[right - start]; right++; &#125; else if (right &gt; end) &#123; array[k] = aux[left - start]; left++; &#125; else if (aux[left - start] &gt; aux[right - start]) &#123; array[k] = aux[right - start]; right++; &#125; else &#123; array[k] = aux[left - start]; left++; &#125; &#125;&#125; 5、堆排序12345678910111213141516171819202122232425262728293031 原理：堆排序就是利用堆进行排序的方法.基本思想是:将待排序的序列构造成一个大顶堆.此时,整个序列的最大值就是堆顶的根结点.将它移走(其实就是将其与堆数组的末尾元素交换,此时末尾元素就是最大值),然后将剩余的n-1个序列重新构造成一个堆,这样就会得到n个元素的次大值.如此反复执行,便能得到一个有序序列了。 步骤：5.1 构造最大堆（Build_Max_Heap）：若数组下标范围为0~n，考虑到单独一个元素是大根堆，则从下标n/2开始的元素均为大根堆。于是只要从n/2-1开始，向前依次构造大根堆，这样就能保证，构造到某个节点时，它的左右子树都已经是大根堆。5.2 堆排序（HeapSort）：由于堆是用数组模拟的。得到一个大根堆后，数组内部并不是有序的。因此需要将堆化数组有序化。思想是移除根节点，并做最大堆调整的递归运算。第一次将heap[0]与heap[n-1]交换，再对heap[0...n-2]做最大堆调整。第二次将heap[0]与heap[n-2]交换，再对heap[0...n-3]做最大堆调整。重复该操作直至heap[0]和heap[1]交换。由于每次都是将最大的数并入到后面的有序区间，故操作完后整个数组就是有序的了。 5.3 最大堆调整（Max_Heapify）：该方法是提供给上述两个过程调用的。目的是将堆的末端子节点作调整，使得子节点永远小于父节点 。public int[] sort(int[] arr) &#123; int len = arr.length - 1; for (int i = len / 2 - 1; i &gt;= 0; i--) &#123; headAdjust(arr, i, len); &#125; while (len &gt;= 0) &#123; SortUtil.swap(arr, 0, len--); headAdjust(arr, 0, len); &#125; return arr;&#125;private void headAdjust(int[] arr, int parent, int len) &#123; int leftChild, rightChild, maxChild; while ((leftChild = 2 * parent + 1) &lt;= len) &#123; rightChild = leftChild + 1; maxChild = leftChild; // 将maxChild指向左右子节点中的较大者 if (maxChild &lt; len &amp;&amp; (arr[leftChild] &lt; arr[rightChild])) &#123; maxChild++; &#125; if (arr[parent] &lt; arr[maxChild]) &#123; SortUtil.swap(arr, parent, maxChild); parent = maxChild; &#125; else &#123; break; &#125; &#125;&#125; 6、希尔排序123456789101112131415 原理：先将整个待排元素序列分割成若干子序列（由相隔某个“增量”的元素组成的）分别进行直接插入排序，然后依次缩减增量再进行排序，待整个序列中的元素基本有序（增量足够小）时，再对全体元素进行一次直接插入排序（增量为1）。其时间复杂度为O( n^3/2 ),要好于直接插入排序的O(n^2)int gap = arr.length / 2;while (gap &gt;= 1) &#123; for (int i = gap; i &lt; arr.length; i++) &#123; int temp = arr[i]; int j = i - gap; while (j &gt;= 0 &amp;&amp; arr[j] &gt; temp) &#123; arr[j + gap] = arr[j]; j -= gap; &#125; arr[j + gap] = temp; &#125; gap /= 2;&#125; 7、快速排序1234567891011121314151617181920212223 原理：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。 步骤：7.1 从数列中挑出一个元素作为基准数。 7.2 分区过程，将比基准数大的放到右边，小于或等于它的数都放到左边。 7.3 再对左右区间递归执行第二步，直至各区间只有一个数。private void quickSort(int[] arr, int left, int right) &#123; if (left &gt;= right) return; int i = left, j = right, temp = arr[left]; while (i &lt; j) &#123; while (i &lt; j &amp;&amp; arr[j] &gt;= temp) &#123; j--; &#125; while (i &lt; j &amp;&amp; arr[i] &lt;= temp) &#123; i++; &#125; if (i &lt; j) &#123; SortUtil.swap(arr, i, j); &#125; &#125; arr[left] = arr[i]; arr[i] = temp; quickSort(arr, left, i - 1); quickSort(arr, i + 1, right);&#125;","tags":[{"name":"排序","slug":"排序","permalink":"http://yoursite.com/tags/排序/"}]}]