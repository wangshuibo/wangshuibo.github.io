[{"title":"Android_View事件分发机制02","date":"2018-05-31T03:05:17.000Z","path":"2018/05/31/Android-View事件分发机制02/","text":"前言 从上一章节(Activity事件分发机制可知道)，ViewGroup事件分发机制从dispatchTouchEvent()开始。 源码分析(直接、简单) (我用的是API 27的源码) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220@Override public boolean dispatchTouchEvent(MotionEvent ev) &#123; if (mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onTouchEvent(ev, 1); &#125; // If the event targets the accessibility focused view and this is it, start // normal event dispatch. Maybe a descendant is what will handle the click. if (ev.isTargetAccessibilityFocus() &amp;&amp; isAccessibilityFocusedViewOrHost()) &#123; ev.setTargetAccessibilityFocus(false); &#125; boolean handled = false; if (onFilterTouchEventForSecurity(ev)) &#123; final int action = ev.getAction(); final int actionMasked = action &amp; MotionEvent.ACTION_MASK; // Handle an initial down. if (actionMasked == MotionEvent.ACTION_DOWN) &#123; // Throw away all previous state when starting a new touch gesture. // The framework may have dropped the up or cancel event for the previous gesture // due to an app switch, ANR, or some other state change. cancelAndClearTouchTargets(ev); resetTouchState(); &#125; // Check for interception. final boolean intercepted; // 用来标记ViewGroup是否拦截Touch事件的传递。 if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) &#123;// 当事件是按下的时候，或者找到了能够接收touch事件的目标组件 final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) &#123; intercepted = onInterceptTouchEvent(ev); ev.setAction(action); // restore action in case it was changed &#125; else &#123; intercepted = false; &#125; &#125; else &#123; // There are no touch targets and this action is not an initial down // so this view group continues to intercept touches. intercepted = true; &#125; // If intercepted, start normal event dispatch. Also if there is already // a view that is handling the gesture, do normal event dispatch. if (intercepted || mFirstTouchTarget != null) &#123; ev.setTargetAccessibilityFocus(false); &#125; // Check for cancelation. final boolean canceled = resetCancelNextUpFlag(this) || actionMasked == MotionEvent.ACTION_CANCEL; // Update list of touch targets for pointer down, if needed. final boolean split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != 0; TouchTarget newTouchTarget = null; boolean alreadyDispatchedToNewTouchTarget = false; if (!canceled &amp;&amp; !intercepted) &#123;//如果不是ACTION_CANCEL而且不拦截的情况下，遍历ViewGroup的子View。 // If the event is targeting accessiiblity focus we give it to the // view that has accessibility focus and if it does not handle it // we clear the flag and dispatch the event to all children as usual. // We are looking up the accessibility focused host to avoid keeping // state since these events are very rare. View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus() ? findChildWithAccessibilityFocus() : null; if (actionMasked == MotionEvent.ACTION_DOWN || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN) || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123; final int actionIndex = ev.getActionIndex(); // always 0 for down final int idBitsToAssign = split ? 1 &lt;&lt; ev.getPointerId(actionIndex) : TouchTarget.ALL_POINTER_IDS; // Clean up earlier touch targets for this pointer id in case they // have become out of sync. removePointersFromTouchTargets(idBitsToAssign); final int childrenCount = mChildrenCount; if (newTouchTarget == null &amp;&amp; childrenCount != 0) &#123; final float x = ev.getX(actionIndex); final float y = ev.getY(actionIndex); // Find a child that can receive the event. // Scan children from front to back. final ArrayList&lt;View&gt; preorderedList = buildTouchDispatchChildList(); final boolean customOrder = preorderedList == null &amp;&amp; isChildrenDrawingOrderEnabled(); final View[] children = mChildren; for (int i = childrenCount - 1; i &gt;= 0; i--) &#123;// 倒序遍历（为什么是倒序呢？ 因为addView()，后添加的View是放在上面的） final int childIndex = getAndVerifyPreorderedIndex( childrenCount, i, customOrder); final View child = getAndVerifyPreorderedView( preorderedList, children, childIndex); // If there is a view that has accessibility focus we want it // to get the event first and if not handled we will perform a // normal dispatch. We may do a double iteration but this is // safer given the timeframe. if (childWithAccessibilityFocus != null) &#123; if (childWithAccessibilityFocus != child) &#123; continue; &#125; childWithAccessibilityFocus = null; i = childrenCount - 1; &#125; if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) &#123; ev.setTargetAccessibilityFocus(false); //canViewReceivePointerEvents 返回的是 当前view可见或者正在执行动画 //isTransformedTouchPointInView 返回的是触摸点是否在View中 // 过滤掉不可以见的，并且当前触摸的坐标不在子View范围内的子View。 continue; &#125; newTouchTarget = getTouchTarget(child); if (newTouchTarget != null) &#123; // Child is already receiving touch within its bounds. // Give it the new pointer in addition to the ones it is handling. newTouchTarget.pointerIdBits |= idBitsToAssign; break; &#125; resetCancelNextUpFlag(child); if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) &#123; // Child wants to receive touch within its bounds. mLastTouchDownTime = ev.getDownTime(); if (preorderedList != null) &#123; // childIndex points into presorted list, find original index for (int j = 0; j &lt; childrenCount; j++) &#123; if (children[childIndex] == mChildren[j]) &#123; mLastTouchDownIndex = j; break; &#125; &#125; &#125; else &#123; mLastTouchDownIndex = childIndex; &#125; mLastTouchDownX = ev.getX(); mLastTouchDownY = ev.getY(); newTouchTarget = addTouchTarget(child, idBitsToAssign); alreadyDispatchedToNewTouchTarget = true; break; &#125; // The accessibility focus didn&apos;t handle the event, so clear // the flag and do a normal dispatch to all children. ev.setTargetAccessibilityFocus(false); &#125; if (preorderedList != null) preorderedList.clear(); &#125; if (newTouchTarget == null &amp;&amp; mFirstTouchTarget != null) &#123; // Did not find a child to receive the event. // Assign the pointer to the least recently added target. newTouchTarget = mFirstTouchTarget; while (newTouchTarget.next != null) &#123; newTouchTarget = newTouchTarget.next; &#125; newTouchTarget.pointerIdBits |= idBitsToAssign; &#125; &#125; &#125; // Dispatch to touch targets. if (mFirstTouchTarget == null) &#123; // No touch targets so treat this as an ordinary view. handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS); &#125; else &#123; // Dispatch to touch targets, excluding the new touch target if we already // dispatched to it. Cancel touch targets if necessary. TouchTarget predecessor = null; TouchTarget target = mFirstTouchTarget; while (target != null) &#123; final TouchTarget next = target.next; if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123; handled = true; &#125; else &#123; final boolean cancelChild = resetCancelNextUpFlag(target.child) || intercepted; if (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) &#123; handled = true; &#125; if (cancelChild) &#123; if (predecessor == null) &#123; mFirstTouchTarget = next; &#125; else &#123; predecessor.next = next; &#125; target.recycle(); target = next; continue; &#125; &#125; predecessor = target; target = next; &#125; &#125; // Update list of touch targets for pointer up or cancel, if needed. if (canceled || actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123; resetTouchState(); &#125; else if (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_UP) &#123; final int actionIndex = ev.getActionIndex(); final int idBitsToRemove = 1 &lt;&lt; ev.getPointerId(actionIndex); removePointersFromTouchTargets(idBitsToRemove); &#125; &#125; if (!handled &amp;&amp; mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1); &#125; return handled; &#125; 解释一下disallowIntercept 是指是否禁用掉事件拦截的功能。默认都是false。首先判断是否拦截事件。如果没有禁用掉事件拦截的话，就获取onInterceptTouchEvent的返回值；如果禁用掉事件拦截的话，就直接给intercepted 赋值false，表示事件不会被拦截。canceled 赋值的是检查是否取消动作ACTION_CANCEL。 里面调用了里面调用了dispatchTransformedTouchEvent() 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/** * Transforms a motion event into the coordinate space of a particular child view, * filters out irrelevant pointer ids, and overrides its action if necessary. * If child is null, assumes the MotionEvent will be sent to this ViewGroup instead. */ private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel, View child, int desiredPointerIdBits) &#123; final boolean handled; // Canceling motions is a special case. We don&apos;t need to perform any transformations // or filtering. The important part is the action, not the contents. final int oldAction = event.getAction(); if (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123; event.setAction(MotionEvent.ACTION_CANCEL); if (child == null) &#123; handled = super.dispatchTouchEvent(event); &#125; else &#123; handled = child.dispatchTouchEvent(event); &#125; event.setAction(oldAction); return handled; &#125; // Calculate the number of pointers to deliver. final int oldPointerIdBits = event.getPointerIdBits(); final int newPointerIdBits = oldPointerIdBits &amp; desiredPointerIdBits; // If for some reason we ended up in an inconsistent state where it looks like we // might produce a motion event with no pointers in it, then drop the event. if (newPointerIdBits == 0) &#123; return false; &#125; // If the number of pointers is the same and we don&apos;t need to perform any fancy // irreversible transformations, then we can reuse the motion event for this // dispatch as long as we are careful to revert any changes we make. // Otherwise we need to make a copy. final MotionEvent transformedEvent; if (newPointerIdBits == oldPointerIdBits) &#123; if (child == null || child.hasIdentityMatrix()) &#123; if (child == null) &#123; handled = super.dispatchTouchEvent(event); &#125; else &#123; final float offsetX = mScrollX - child.mLeft; final float offsetY = mScrollY - child.mTop; event.offsetLocation(offsetX, offsetY); handled = child.dispatchTouchEvent(event); event.offsetLocation(-offsetX, -offsetY); &#125; return handled; &#125; transformedEvent = MotionEvent.obtain(event); &#125; else &#123; transformedEvent = event.split(newPointerIdBits); &#125; // Perform any necessary transformations and dispatch. if (child == null) &#123; handled = super.dispatchTouchEvent(transformedEvent); &#125; else &#123; final float offsetX = mScrollX - child.mLeft; final float offsetY = mScrollY - child.mTop; transformedEvent.offsetLocation(offsetX, offsetY); if (! child.hasIdentityMatrix()) &#123; transformedEvent.transform(child.getInverseMatrix()); &#125; handled = child.dispatchTouchEvent(transformedEvent); &#125; // Done. transformedEvent.recycle(); return handled; &#125; 如果传入的子View不=为空的话，就传递给子View中的dispatchTouchEvent方法调用。如果为空，就传递给ViewGroup自身的dispatchTouchEvent()。这里调用的是 super.dispatchTouchEvent(event)，ViewGroup的父类虽然是一个View，但是实际上还是一个ViewGroup，相当于调用自身的dispatchTouchEvent。 流程图 下章节继续讲解View分发事件的源码分析","comments":true,"tags":[{"name":"Android_View事件分发机制02","slug":"Android-View事件分发机制02","permalink":"/tags/Android-View事件分发机制02/"}]},{"title":"Android View事件分发机制01","date":"2018-05-27T07:51:53.000Z","path":"2018/05/27/Android_View事件分发机制01/","text":"前言 从Activity开始分发 当用户触摸屏幕时（View 或 ViewGroup派生的控件），将产生点击事件（Touch事件） Touch事件的相关细节（发生触摸的位置、时间等）被封装成MotionEvent对象 事件类型(4种) 事件类型 具体动作 MotionEvent.ACTION_DOWN 按下View（所有事件的开始) MotionEvent.ACTION_UP 抬起View（与DOWN对应) MotionEvent.ACTION_MOVE 滑动View MotionEvent.ACTION_CANCEL 结束事件（非人为原因) 事件在哪些对象之间进行传递 Activity—&gt;ViewGroup—&gt;View 核心方法 dispatchTouchEvent()—&gt;onInterceptTouchEvent()(备注:这个方法只有ViewGroup有,View和Activity没有)—&gt;onTouchEvent() 源码分析 1234567891011121314151617181920212223242526272829303132333435Activity 源码分析/** * Called to process touch screen events. You can override this to * intercept all touch screen events before they are dispatched to the * window. Be sure to call this implementation for touch screen events * that should be handled normally. * * @param ev The touch screen event. * * @return boolean Return true if this event was consumed. */ public boolean dispatchTouchEvent(MotionEvent ev) &#123; // 一般事件列开始都是DOWN事件 = 按下事件，故此处基本是true if (ev.getAction() == MotionEvent.ACTION_DOWN) &#123; onUserInteraction(); &#125; if (getWindow().superDispatchTouchEvent(ev)) &#123; return true; // 若getWindow().superDispatchTouchEvent(ev)的返回true // 则Activity.dispatchTouchEvent（）就返回true，则方法结束。即 ：该点击事件停止往下传递 &amp; 事件传递过程结束 // 否则：继续往下调用Activity.onTouchEvent &#125; return onTouchEvent(ev); &#125;/** * 分析1：onUserInteraction() * 作用：实现屏保功能 * 注： * a. 该方法为空方法 * b. 当此activity在栈顶时，触屏点击按home，back，menu键等都会触发此方法 */ public void onUserInteraction() &#123; &#125; 接着我们继续看 superDispatchTouchEvent(ev) 方法 这里我在说下窗口机制:主要是由Activity—&gt;PhoneWindow—&gt;DecorView—&gt;ContentView，也就是PhoneWindow通过继承Window抽象类,然后触发这个方法，接着调用DecorView方法,将当前手势传下去，因为DecorView是继承FrameLayout。由于FrameLayout的父类是ViewGroup，DecorView间接=ViewGroup(下一章节会说到) 1234567891011121314/** * 分析2：getWindow().superDispatchTouchEvent(ev) * 说明： * a. getWindow() = 获取Window类的对象 * b. Window类是抽象类，其唯一实现类 = PhoneWindow类；即此处的Window类对象 = PhoneWindow类对象 * c. Window类的superDispatchTouchEvent() = 1个抽象方法，由子类PhoneWindow类实现 */ @Override public boolean superDispatchTouchEvent(MotionEvent event) &#123; return mDecor.superDispatchTouchEvent(event); // mDecor = 顶层View（DecorView）的实例对象 &#125; 流程图 放松一下,图片走起,哈哈哈 。下章节继续讲解ViewGroup事件分发机制","comments":true,"tags":[{"name":"Android View事件分发机制01","slug":"Android-View事件分发机制01","permalink":"/tags/Android-View事件分发机制01/"}]},{"title":"retrofit源码分析","date":"2018-05-06T04:01:29.309Z","path":"2018/05/06/retrofit/","text":"导言retrofit的最大特点就是解耦，要解耦就需要大量的设计模式。假如一点设计模式都不懂的人，可能很难看懂retrofit。~_~ 不要着急, 先上图，压压惊。 首先呢，还是看一下流程图。（如果哪有遗漏，可以私发给我 QQ号:203911607） 主体下面讲解一下主流程: 1.创建一个接口进行HTTP请求描述；2.使用Retrofit.Builder构建模式构造出一个Retrofit实例；3.调用retrofit.create()方法获取请求接口实例；4.由请求接口实例获取到Call对象；进行网络请求（同步/异步）接下来，我们就按照以上正常的网络请求顺序来对Retrofit源码进行解析。 创建一个接口进行HTTP请求描述 public interface ApiService { @GET(“users/{user}/gg”) Call bean(@Path(“user”) String user);}这里主要做的就是采用注解的方式进行HTTP描述，后面在第4步由请求接口实例获取到Call对象时进行反射提取注解内容进行HTTP请求构造（如果开启了预先加载解析（validateEagerly=true），那么在第3步调用retrofit.create()方法获取请求接口实例的时候就会进行注解解析），具体解析方法参考后续分析。 使用Retrofit.Builder构建模式构造出一个Retrofit实例123Retrofit retrofit = new Retrofit.Builder() .baseUrl(\"https://wangshuipo.top/\") .build(); 那我们就先来看下Retrofit.Builder部分源码: 1234567891011121314151617181920/** * Build a new &#123;@link Retrofit&#125;. * Calling &#123;@link #baseUrl&#125; is required before calling &#123;@link #build()&#125;. All other methods * are optional. */ public static final class Builder &#123; private final Platform platform; //callFactory通过newCall(Request request)方法，返回一个okhttp3.Call对象，以便让我们进行实际的HTTP请求 //也就是说callFactory是我们用来生成一个客户端HTTP请求工厂实例 private @Nullable okhttp3.Call.Factory callFactory; private HttpUrl baseUrl; //converterFactories生产Converter&lt;F, T&gt;，用于将HTTP返回结果F类型转换为T类型，或将HTTP请求类型F转换为T。 private final List&lt;Converter.Factory&gt; converterFactories = new ArrayList&lt;&gt;(); //adapterFactories生产 CallAdapter&lt;R, T&gt;，用于将retrofit2.Call&lt;R&gt;网络请求类型转换为T类型：T adapt(Call&lt;R&gt; var1); private final List&lt;CallAdapter.Factory&gt; adapterFactories = new ArrayList&lt;&gt;(); private @Nullable Executor callbackExecutor; private boolean validateEagerly; ···&#125; 从Retrofit.Builder的注释中，我们可以看到，在调用Retrofit.Builder.build()之前，除了baseUrl()是必须配置的以外，其他的内容都是可选配置。这里要对两个类型做下讲解，因为笔者在刚分析Retrofit源码时，被这两个类型的概念弄得头晕眼胀，好在一顿分析后，终于有了一点眉目，这两个类型就是：Converter和CallAdapter。Converter：数据转换器，用来将HTTP请求返回结果由F类型转换为T类型，或者将HTTP请求类型F转换为T123456789public interface Converter&lt;F, T&gt; &#123; T convert(F value) throws IOException; ···&#125;//举例：new Retrofit.Builder() .baseUrl(\"https://wangshuipo.top/\") .addConverterFactory(GsonConverterFactory.create()) .build(); 上面配置了ConverterFactory为GsonConverterFactory，那么当HTTP请求结果返回时，就会由GsonConverterFactory产生的Converter，假设为Converter","comments":true,"tags":[{"name":"retrofit源码分析","slug":"retrofit源码分析","permalink":"/tags/retrofit源码分析/"}]},{"title":"git提交基本命令","date":"2018-04-24T08:03:56.948Z","path":"2018/04/24/gitStyle/","text":"基本命令:1.ls -a 表示使用lunix命令查看文件夹下的文件。 2.git init 表示初始化一个空的git仓库。 3.git status 表示默认生成的仓库里该文件夹里面的文件没有追踪，这个命令可以查看当前状态。 4.git add 文件名 表示添加到暂存区，追踪。 5.git commit -m &apos;可以添加描述&apos; 表示提交文件。 6.git log 表示查看提交信息。 7.git add . 表示可以添加全部文件。 8.git commit -am &apos;可以添加描述&apos; 表示添加并提交文件。 9.git log --oneline 表示只查看描述信息。 git的三层结构1.working directory 工作区 2.staging index 暂存区 3.git directory(Repository)版本库 git中文件四种状态1.untracked:未追踪 2.Modified:表示工作区修改了某个文件但是还没有添加到暂存区 3.Stage:表示把工作区修改的文件添加到暂存区但是没有提交到版本库 4.Committed:表示数据被安全的存储在本地仓库中 git撤销操作1.git commit --amend 撤销上一次提交，并将暂存区的文件重新提交。(注意跳出是先按Esc，然后输入输入:wq再按Enter键) 2.git checkout -- filename 拉取暂存区的文件并将其替换工作区的文件，注意与git checkout branchname区别 3.git reset HEAD -- filename 拉取最近一次提交的版本库中的这个文件到暂存区，该操作不影响工作区。(可以在git log 中选择其中的一个版本号替换HEAD,这么做可以拉回上一次提交的样式。具体写法git reset 选择想要替换回来的一次版本号 filename ) 4.git reset --options 版本号{options可以替换--hard --mixed --soft } git文件删除1.git rm --filename {1.删除工作区及暂存区中的改文件相当于删除文件后执行 git add 2.git rm --cached filename 在不小心将不需要追踪的文件添加到暂存区，想要删除暂存的文件但不想删除工作区的文件很有用(应用场景.gitignore.git远程仓库) 3.git rm -f filename 当工作区或者暂存区文件修改了(防止把修改误删除了) 4.glob模式--星号(*)匹配零个或多个任意字符 --[abc] 匹配任何一个列在方括号中的字符--问号(?)只匹配一个任意字符 --[0-9]、[a-z]匹配范围 } 2.git mv --filename 相当于 {1.mv oldname newname 2.git rm oldname 3.git add newname } git分支1.git 分支的创建、修改、切换、删除{1.git branch 查看分支 2.git branch branchname创建分支 3.git branch -m oldname newname 修改分支名称 4.git checkout [-b] branchname 如果加上-b命令的意思是创建该分支并且切换分支,反之只是切换分支 5.git branch -D branchname删除分支 } 2. git 分支合并 2-1.分值的指南--HEAD指向当前工作的分支--再切换分支时指向新的分支 2-2.git diff{1.git diff 比较工作区与暂存区文件的差异 2.git diff --staged 比较暂存区与版本库的文件差异 3.git diff 版本号 版本号 比较分支内两个版本的差异 4.git diff 分支 分支 比较两个分支的最新提交版本的差异 } 2-3.git merge branchname 合并之前需要先切换到master分支--快速合并和冲突合并 3.存储变更 3-1.git stash 3-2.git stash list 3-3.git stash apply stash@num git stash apply 后面不加名字则应用最近一次存储信息 3-4.git stash drop stash@num git stash apply 只是运用存储信息，并不删除他，drop命令可以删除它 git 远程仓库1.github上的仓库{1.创建仓库 2.clone仓库到本地 3.本地push到仓库 4.pull代码到本地 5.ignoring files } 2.远程服务器上的仓库{1.用taskmanager来演示 2.git init --bare 3.git remote add name path 4.git remote rm name 5.git remote rename oldname newname 6.git fetch } 3.Git ssh免密登录{1.首先要配置username和邮箱 git config --global user.name yinlijun git config user.email aaa@aaa.com如果配置了就不要配置 ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 2.ssh-copy-id user@host 将本机的公钥复制到远程服务器的authorized_keys文件中 3.如果不是自己的服务器可以将本地公钥发给服务器管理员添加在authorized_keys文件后面 4. } Git帮助文档的使用1.git help 2.git help command 3.官方地址---http://git-scm.com/docs http://www.wangshuibo.github.io","comments":true,"tags":[{"name":"git命令","slug":"git命令","permalink":"/tags/git命令/"}]},{"title":"七种基本排序算法的实现和总结","date":"2017-12-10T08:33:18.179Z","path":"2017/12/10/px/","text":"1、冒泡排序123456789101112 原理：每次比较两个相邻的元素，如果它们的顺序错误就把它们交换过来。 步骤：1.1 比较相邻的元素。如果倒数第一个比倒数第二个小，就交换他们两个。 1.2 对第0个到第n-1个数据做同样的工作。这时，最小的数就“浮”到了数组最开始的位置上。 1.3 针对所有的元素重复以上的步骤，除了第一个。 1.4 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。for (int i = 0; i &lt; arr.length; i++) &#123; for (int j = arr.length - 1; j &gt; i; j--) &#123; if (arr[j] &lt; arr[j - 1]) &#123; SortUtil.swap(arr, j, j - 1); &#125; &#125;&#125; 2、选择排序12345678910111213 原理：不断地选择剩余元素中的最小者 步骤：2.1 找到数组中最小元素的下标，将第一个元素与最小元素下标的数进行交换。 2.2 在剩下的元素中找到最小元素下标并将其与数组第二个元素交换，直至整个数组排序。for (int i = 0; i &lt; arr.length; i++) &#123; int minIndex = i; for (int j = i + 1; j &lt; arr.length; j++) &#123; if (arr[j] &lt; arr[minIndex]) &#123; minIndex = j; &#125; &#125; SortUtil.swap(arr, minIndex, i);&#125; 3、插入排序123456789101112131415 原理：插入排序的工作原理是，对于每个未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。 步骤：3.1 从第一个元素开始，该元素可以认为已经被排序 3.2 取出下一个元素，在已经排序的元素序列中从后向前扫描 3.3 如果被扫描的元素（已排序）大于新元素，将该元素后移一位 3.4 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置 3.5 将新元素插入到该位置后 3.6 重复步骤2~5for (int i = 1; i &lt; arr.length; i++) &#123; int temp = arr[i]; int j; for (j = i; j &gt; 0 &amp;&amp; (arr[j - 1] &gt; temp); j--) &#123; arr[j] = arr[j -1]; &#125; arr[j] = temp;&#125; 4、归并排序12345678910111213141516171819202122232425262728293031323334 原理：将长度为n的记录不断划分，划分到长度为1时，再两两合并，依次递归。主要是利用分治法来处理。@Overridepublic int[] sort(int[] arr) &#123; mergeSort(arr, 0, arr.length - 1); return arr;&#125;private void mergeSort(int[] array, int start, int end) &#123; if (start &gt;= end) return; int middle = (start + end) / 2; mergeSort(array, start, middle); mergeSort(array, middle + 1, end); merge(array, start, middle, end);&#125;private void merge(int[] array, int start, int middle, int end) &#123; int[] aux = new int[end - start + 1]; System.arraycopy(array, start, aux, 0, end - start + 1); int left = start; int right = middle + 1; for (int k = start; k &lt;= end; k++) &#123; if (left &gt; middle) &#123; array[k] = aux[right - start]; right++; &#125; else if (right &gt; end) &#123; array[k] = aux[left - start]; left++; &#125; else if (aux[left - start] &gt; aux[right - start]) &#123; array[k] = aux[right - start]; right++; &#125; else &#123; array[k] = aux[left - start]; left++; &#125; &#125;&#125; 5、堆排序12345678910111213141516171819202122232425262728293031 原理：堆排序就是利用堆进行排序的方法.基本思想是:将待排序的序列构造成一个大顶堆.此时,整个序列的最大值就是堆顶的根结点.将它移走(其实就是将其与堆数组的末尾元素交换,此时末尾元素就是最大值),然后将剩余的n-1个序列重新构造成一个堆,这样就会得到n个元素的次大值.如此反复执行,便能得到一个有序序列了。 步骤：5.1 构造最大堆（Build_Max_Heap）：若数组下标范围为0~n，考虑到单独一个元素是大根堆，则从下标n/2开始的元素均为大根堆。于是只要从n/2-1开始，向前依次构造大根堆，这样就能保证，构造到某个节点时，它的左右子树都已经是大根堆。5.2 堆排序（HeapSort）：由于堆是用数组模拟的。得到一个大根堆后，数组内部并不是有序的。因此需要将堆化数组有序化。思想是移除根节点，并做最大堆调整的递归运算。第一次将heap[0]与heap[n-1]交换，再对heap[0...n-2]做最大堆调整。第二次将heap[0]与heap[n-2]交换，再对heap[0...n-3]做最大堆调整。重复该操作直至heap[0]和heap[1]交换。由于每次都是将最大的数并入到后面的有序区间，故操作完后整个数组就是有序的了。 5.3 最大堆调整（Max_Heapify）：该方法是提供给上述两个过程调用的。目的是将堆的末端子节点作调整，使得子节点永远小于父节点 。public int[] sort(int[] arr) &#123; int len = arr.length - 1; for (int i = len / 2 - 1; i &gt;= 0; i--) &#123; headAdjust(arr, i, len); &#125; while (len &gt;= 0) &#123; SortUtil.swap(arr, 0, len--); headAdjust(arr, 0, len); &#125; return arr;&#125;private void headAdjust(int[] arr, int parent, int len) &#123; int leftChild, rightChild, maxChild; while ((leftChild = 2 * parent + 1) &lt;= len) &#123; rightChild = leftChild + 1; maxChild = leftChild; // 将maxChild指向左右子节点中的较大者 if (maxChild &lt; len &amp;&amp; (arr[leftChild] &lt; arr[rightChild])) &#123; maxChild++; &#125; if (arr[parent] &lt; arr[maxChild]) &#123; SortUtil.swap(arr, parent, maxChild); parent = maxChild; &#125; else &#123; break; &#125; &#125;&#125; 6、希尔排序123456789101112131415 原理：先将整个待排元素序列分割成若干子序列（由相隔某个“增量”的元素组成的）分别进行直接插入排序，然后依次缩减增量再进行排序，待整个序列中的元素基本有序（增量足够小）时，再对全体元素进行一次直接插入排序（增量为1）。其时间复杂度为O( n^3/2 ),要好于直接插入排序的O(n^2)int gap = arr.length / 2;while (gap &gt;= 1) &#123; for (int i = gap; i &lt; arr.length; i++) &#123; int temp = arr[i]; int j = i - gap; while (j &gt;= 0 &amp;&amp; arr[j] &gt; temp) &#123; arr[j + gap] = arr[j]; j -= gap; &#125; arr[j + gap] = temp; &#125; gap /= 2;&#125; 7、快速排序1234567891011121314151617181920212223 原理：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。 步骤：7.1 从数列中挑出一个元素作为基准数。 7.2 分区过程，将比基准数大的放到右边，小于或等于它的数都放到左边。 7.3 再对左右区间递归执行第二步，直至各区间只有一个数。private void quickSort(int[] arr, int left, int right) &#123; if (left &gt;= right) return; int i = left, j = right, temp = arr[left]; while (i &lt; j) &#123; while (i &lt; j &amp;&amp; arr[j] &gt;= temp) &#123; j--; &#125; while (i &lt; j &amp;&amp; arr[i] &lt;= temp) &#123; i++; &#125; if (i &lt; j) &#123; SortUtil.swap(arr, i, j); &#125; &#125; arr[left] = arr[i]; arr[i] = temp; quickSort(arr, left, i - 1); quickSort(arr, i + 1, right);&#125;","comments":true,"tags":[{"name":"排序","slug":"排序","permalink":"/tags/排序/"}]}]