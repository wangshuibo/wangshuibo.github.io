[{"title":"看过来Android P刘海屏适配大全","date":"2018-07-25T12:37:18.404Z","path":"2018/07/25/看过来Android P刘海屏适配大全/","text":"[TOC] 前言 随着 Apple 发布 iPhone X 之后，各大手机厂商也开始模仿这种刘海屏的设计，而且刘海屏手机的用户也是越来越多，前段时间将项目进行了所有主流厂商的刘海屏手机的适配，以便让刘海屏手机的用户也能有更好的体验。在我看来，引领新的技术是OK的，但是跟班别人我就看不惯了。 一、刘海屏造成UI显示问题 刘海屏手机因为比平常的手机多了一块顶部的遮挡性刘海，所以会造成顶部 Toolbar 以及搜索框的遮挡，而且有些厂商的手机（vivo、华为），默认是在「无状态栏」的界面将状态栏进行黑化显示，这时候会导致系统下移，从而导致底部的一些 UI 被截断。 二、通用适配方案 理论上来讲，通过 Android P 版本提供的刘海屏相关接口，判断手机是否为刘海屏手机，以及进行一些相应的处理是最合适的方式，但现在使用在国内使用 Android P 的接口是不现实的，所以只能通过各大厂商提供的技术文档来进行适配，但适配的流程基本是一致的。 2.1应用是否已经适配刘海屏 当不显示状态栏时，直接将界面进行显示，「状态栏原先的位置也用于显示界面」，例如：OPPO当不显示状态栏时，直接「将状态栏原先的位置进行黑化，界面整体下移」，不去适配，感觉一团黑，不好看呐。例如：华为、vivo 所以，我们在进行刘海屏适配的时候，首先需要通过一些手段，统一各大厂商的显示方案，让所有的刘海屏手机都利用状态栏的界面，「告知系统」我们已经适配了刘海屏，确保系统不会下移我们的应用，保留原生体验。 2.1.1这里主要有两种方式1、设置屏幕高宽比例 因为刘海屏手机的「宽高比」比之前的手机大，如果不适配的话，Android 默认为最大的宽高比为 1.86，小于刘海屏手机的宽高比，因此我们需要申明更高的宽高比来告诉系统，我们应用已经适配了刘海屏。只要在 AndroidManifest.xml 中加入如下配置： 1234&lt;meta-data android:name=&quot;android.max_aspect&quot; android:value=&quot;2.1&quot;/&gt;也可以在 Application 添加属性：android:maxAspectRatio=&quot;ratio_float&quot;ps：这个属性需要 API 26 才支持 2、设置应用支持 resize 我们还可以通过设置应用支持 resizeable，来告诉系统我们适配了刘海屏，而且这也是 Google 官方推荐的方式。不过需要注意的是，使用这个属性之后，应用也会跟着支持分屏模式。只需要在 AndroidManifest.xml 中添加： 1android:resizeableActivity=&quot;true&quot; 2.2 页面是否显示状态栏 对于刘海屏适配，我们将界面分为两种：对于有状态栏的界面，不会受到刘海屏的影响全屏显示的界面（无状态栏），需要根据界面的显示进行一些控件的下移因此，我们进行刘海屏适配，其实针对的就是没有状态栏的界面，而有状态栏的界面显示是正常的。对于没有状态栏的界面，主要是将对被刘海遮挡到的控件，设置对应刘海高度的 MarginTop，从而避免控件被遮挡。 三、各大厂商适配方案 现在 Android P 的接口还没法用，但各手机厂商都制定了自己的 API，对此我们需要对各大机型进行特殊的适配，这里主要介绍 vivo、OPPO、华为 这三种主流手机的适配方案。 3.1华为 华为作为国内的手机厂商大头，自己仿照 Android P 提供的 API，实现了一套几乎差不多的 API，所以我们如果想要告诉系统我们的应用适配了刘海屏，最好直接使用华为的 API，这样才是最保险的。以下代码来自：华为刘海屏适配官方技术指导链接 3.1.1、应用页面设置使用刘海区显示 ① 方案一：在 AndroidManifest.xml 中增加 meta-data 属性，此属性不仅可以针对 Application 生效，也可以对 Activity 配置生效： 12&lt;meta-data android:name=&quot;android.notch_support&quot; android:value=&quot;true&quot;/&gt;增加这个属性之后，系统就会对应用进行下移处理，从而保证原生体验。 ② 方案二：通过添加窗口 FLAG 的方式设置界面使用刘海区： 1234567891011121314151617public static void setFullScreenWindowLayoutInDisplayCutout(Window window) &#123; if (window == null) &#123; return; &#125; WindowManager.LayoutParams layoutParams = window.getAttributes(); try &#123; Class layoutParamsExCls = Class.forName(&quot;com.huawei.android.view.LayoutParamsEx&quot;); Constructor con=layoutParamsExCls.getConstructor(LayoutParams.class); Object layoutParamsExObj=con.newInstance(layoutParams); Method method=layoutParamsExCls.getMethod(&quot;addHwFlags&quot;, int.class); method.invoke(layoutParamsExObj, FLAG_NOTCH_SUPPORT); &#125; catch (ClassNotFoundException | NoSuchMethodException | IllegalAccessException |InstantiationException | InvocationTargetException e) &#123; Log.e(&quot;test&quot;, &quot;hw add notch screen flag api error&quot;); &#125; catch (Exception e) &#123; Log.e(&quot;test&quot;, &quot;other Exception&quot;); &#125;&#125; 3.1.2、判断该华为手机是否刘海屏1234567891011121314public static boolean hasNotchInHuawei(Context context) &#123; boolean hasNotch = false; try &#123; ClassLoader cl = context.getClassLoader(); Class HwNotchSizeUtil = cl.loadClass(&quot;com.huawei.android.util.HwNotchSizeUtil&quot;); Method hasNotchInScreen = HwNotchSizeUtil.getMethod(&quot;hasNotchInScreen&quot;); if(hasNotchInScreen != null) &#123; hasNotch = (boolean) hasNotchInScreen.invoke(HwNotchSizeUtil); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return hasNotch;&#125; 3.1.3、获取刘海的高度12345678910111213141516public static int[] getNotchSize(Context context) &#123; int[] ret = new int[]&#123;0, 0&#125;; try &#123; ClassLoader cl = context.getClassLoader(); Class HwNotchSizeUtil = cl.loadClass(&quot;com.huawei.android.util.HwNotchSizeUtil&quot;); Method get = HwNotchSizeUtil.getMethod(&quot;getNotchSize&quot;); ret = (int[]) get.invoke(HwNotchSizeUtil); &#125; catch (ClassNotFoundException e) &#123; Log.e(&quot;test&quot;, &quot;getNotchSize ClassNotFoundException&quot;); &#125; catch (NoSuchMethodException e) &#123; Log.e(&quot;test&quot;, &quot;getNotchSize NoSuchMethodException&quot;); &#125; catch (Exception e) &#123; Log.e(&quot;test&quot;, &quot;getNotchSize Exception&quot;); &#125; finally &#123; return ret; &#125; 3.2 OPPO OPPO 是主流厂商中的一股清流，学 iPhoneX 是最像的，OPPO 手机对于不显示状态栏的界面，采取的是「状态栏原先的位置也用于显示界面」的方案，所以我们只要进行相关控件的位置移动就可以了。以下代码来自： OPPO 凹形屏适配说明链接 3.2.1、判断该 OPPO 手机是否为刘海屏手机123public static boolean hasNotchInOppo(Context context) &#123; return context.getPackageManager().hasSystemFeature(&quot;com.oppo.feature.screen.heteromorphism&quot;);&#125; 3.2.2、获取刘海屏的高度 对于 OPPO 刘海屏手机的刘海高度，OPPO 官方的文档没有提供相关的 API，但官方文档表示 OPPO 手机的刘海高度和状态栏的高度是一致的，而且我也对此进行了验证，确实如此。所以我们可以直接获取状态栏的高度，作为 OPPO 手机的刘海高度。 12345678public static int getStatusBarHeight(Context context) &#123; int statusBarHeight = 0; int resourceId = context.getResources().getIdentifier(&quot;status_bar_height&quot;, &quot;dimen&quot;, &quot;android&quot;); if (resourceId &gt; 0) &#123; statusBarHeight = context.getResources().getDimensionPixelSize(resourceId); &#125; return statusBarHeight ;&#125; 3.3 VIVO vivo 提供的技术文档对于开发者来说是最不友好的，只提供了一个 API 来进行刘海屏的判断，并没有提供刘海高度的获取方式，我们只能通过获取状态栏高度来当做刘海的高度，但在某些机型可能会有些偏差。官方文档：vivo 手机适配指南链接 3.3.1 判断该 vivo 手机是否为刘海屏手机1234567891011121314151617181920212223public static boolean hasNotchInVivo(Context context) &#123; boolean hasNotch = false; try &#123; ClassLoader cl = context.getClassLoader(); Class ftFeature = cl.loadClass(&quot;android.util.FtFeature&quot;); Method[] methods = ftFeature.getDeclaredMethods(); if (methods != null) &#123; for (int i = 0; i &lt; methods.length; i++) &#123; Method method = methods[i]; if(method != null) &#123; if (method.getName().equalsIgnoreCase(&quot;isFeatureSupport&quot;)) &#123; hasNotch = (boolean) method.invoke(ftFeature, 0x00000020); break; &#125; &#125; &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); hasNotch = false; &#125; return hasNotch;&#125; 四、","comments":true,"tags":[{"name":"Android P刘海屏适配大全","slug":"Android-P刘海屏适配大全","permalink":"/tags/Android-P刘海屏适配大全/"}]},{"title":"Android_View事件分发机制03","date":"2018-05-31T05:27:04.000Z","path":"2018/05/31/Android-View事件分发机制03/","text":"前言 从上一章节(ViewGroup事件分发机制可知道)，View事件分发机制从dispatchTouchEvent()开始。 我们直接上源码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * Pass the touch screen motion event down to the target view, or this * view if it is the target. * * @param event The motion event to be dispatched. * @return True if the event was handled by the view, false otherwise. */ public boolean dispatchTouchEvent(MotionEvent event) &#123; // If the event should be handled by accessibility focus first. if (event.isTargetAccessibilityFocus()) &#123; // We don&apos;t have focus or no virtual descendant has it, do not handle the event. if (!isAccessibilityFocusedViewOrHost()) &#123; return false; &#125; // We have focus and got the event, then use normal event dispatch. event.setTargetAccessibilityFocus(false); &#125; boolean result = false; if (mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onTouchEvent(event, 0); &#125; final int actionMasked = event.getActionMasked(); if (actionMasked == MotionEvent.ACTION_DOWN) &#123; // Defensive cleanup for new gesture stopNestedScroll(); &#125; if (onFilterTouchEventForSecurity(event)) &#123; if ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) &#123; result = true; &#125; //noinspection SimplifiableIfStatement ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnTouchListener.onTouch(this, event)) &#123; result = true; &#125; if (!result &amp;&amp; onTouchEvent(event)) &#123; result = true; &#125; &#125; if (!result &amp;&amp; mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onUnhandledEvent(event, 0); &#125; // Clean up after nested scrolls if this is the end of a gesture; // also cancel it if we tried an ACTION_DOWN but we didn&apos;t want the rest // of the gesture. if (actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_CANCEL || (actionMasked == MotionEvent.ACTION_DOWN &amp;&amp; !result)) &#123; stopNestedScroll(); &#125; return result; &#125; 上面是View的dispatchTouchEvent方法的全部代码。我们一段一段去解释，嘿嘿 12345678910111213141516171819//如果窗口没有被遮盖 if (onFilterTouchEventForSecurity(event)) &#123; if ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) &#123; result = true; &#125; //noinspection SimplifiableIfStatement //当前监听事件 ListenerInfo li = mListenerInfo; //需要特别注意这个判断当中的li.mOnTouchListener.onTouch(this, event)条件 if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnTouchListener.onTouch(this, event)) &#123; result = true; &#125; //result为false调用自己的onTouchEvent方法处理 if (!result &amp;&amp; onTouchEvent(event)) &#123; result = true; &#125; &#125; 通过上面代码我们可以看到View会先判断是否设置了OnTouchListener，如果设置了OnTouchListener并且onTouch方法返回了true，那么onTouchEvent不会被调用。当没有设置OnTouchListener或者设置了OnTouchListener但是onTouch方法返回false则会调用View自己的onTouchEvent方法。接下来看onTouchEvent方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181/** * Implement this method to handle touch screen motion events. * &lt;p&gt; * If this method is used to detect click actions, it is recommended that * the actions be performed by implementing and calling * &#123;@link #performClick()&#125;. This will ensure consistent system behavior, * including: * &lt;ul&gt; * &lt;li&gt;obeying click sound preferences * &lt;li&gt;dispatching OnClickListener calls * &lt;li&gt;handling &#123;@link AccessibilityNodeInfo#ACTION_CLICK ACTION_CLICK&#125; when * accessibility features are enabled * &lt;/ul&gt; * * @param event The motion event. * @return True if the event was handled, false otherwise. */ public boolean onTouchEvent(MotionEvent event) &#123; final float x = event.getX(); final float y = event.getY(); final int viewFlags = mViewFlags; final int action = event.getAction(); final boolean clickable = ((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE; //1.如果View是设置成不可用的（DISABLED）仍然会消费点击事件 if ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123; if (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != 0) &#123; setPressed(false); &#125; mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN; // A disabled view that is clickable still consumes the touch // events, it just doesn&apos;t respond to them. return clickable; &#125; if (mTouchDelegate != null) &#123; if (mTouchDelegate.onTouchEvent(event)) &#123; return true; &#125; &#125; //2.CLICKABLE 和LONG_CLICKABLE只要有一个为true就消费这个事件 if (clickable || (viewFlags &amp; TOOLTIP) == TOOLTIP) &#123; switch (action) &#123; case MotionEvent.ACTION_UP: mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN; if ((viewFlags &amp; TOOLTIP) == TOOLTIP) &#123; handleTooltipUp(); &#125; if (!clickable) &#123; removeTapCallback(); removeLongPressCallback(); mInContextButtonPress = false; mHasPerformedLongPress = false; mIgnoreNextUpEvent = false; break; &#125; boolean prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != 0; if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0 || prepressed) &#123; // take focus if we don&apos;t have it already and we should in // touch mode. boolean focusTaken = false; if (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) &#123; focusTaken = requestFocus(); &#125; if (prepressed) &#123; // The button is being released before we actually // showed it as pressed. Make it show the pressed // state now (before scheduling the click) to ensure // the user sees it. setPressed(true, x, y); &#125; if (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) &#123; // This is a tap, so remove the longpress check removeLongPressCallback(); // Only perform take click actions if we were in the pressed state if (!focusTaken) &#123; // Use a Runnable and post this rather than calling // performClick directly. This lets other visual state // of the view update before click actions start. if (mPerformClick == null) &#123; mPerformClick = new PerformClick(); &#125; if (!post(mPerformClick)) &#123; //3.在ACTION_UP方法发生时会触发performClick()方法 performClick(); &#125; &#125; &#125; if (mUnsetPressedState == null) &#123; mUnsetPressedState = new UnsetPressedState(); &#125; if (prepressed) &#123; postDelayed(mUnsetPressedState, ViewConfiguration.getPressedStateDuration()); &#125; else if (!post(mUnsetPressedState)) &#123; // If the post failed, unpress right now mUnsetPressedState.run(); &#125; removeTapCallback(); &#125; mIgnoreNextUpEvent = false; break; case MotionEvent.ACTION_DOWN: if (event.getSource() == InputDevice.SOURCE_TOUCHSCREEN) &#123; mPrivateFlags3 |= PFLAG3_FINGER_DOWN; &#125; mHasPerformedLongPress = false; if (!clickable) &#123; checkForLongClick(0, x, y); break; &#125; if (performButtonActionOnTouchDown(event)) &#123; break; &#125; // Walk up the hierarchy to determine if we&apos;re inside a scrolling container. boolean isInScrollingContainer = isInScrollingContainer(); // For views inside a scrolling container, delay the pressed feedback for // a short period in case this is a scroll. if (isInScrollingContainer) &#123; mPrivateFlags |= PFLAG_PREPRESSED; if (mPendingCheckForTap == null) &#123; mPendingCheckForTap = new CheckForTap(); &#125; mPendingCheckForTap.x = event.getX(); mPendingCheckForTap.y = event.getY(); postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout()); &#125; else &#123; // Not inside a scrolling container, so show the feedback right away setPressed(true, x, y); checkForLongClick(0, x, y); &#125; break; case MotionEvent.ACTION_CANCEL: if (clickable) &#123; setPressed(false); &#125; removeTapCallback(); removeLongPressCallback(); mInContextButtonPress = false; mHasPerformedLongPress = false; mIgnoreNextUpEvent = false; mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN; break; case MotionEvent.ACTION_MOVE: if (clickable) &#123; drawableHotspotChanged(x, y); &#125; // Be lenient about moving outside of buttons if (!pointInView(x, y, mTouchSlop)) &#123; // Outside button // Remove any future long press/tap checks removeTapCallback(); removeLongPressCallback(); if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0) &#123; setPressed(false); &#125; mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN; &#125; break; &#125; return true; &#125; return false; &#125; 述代码有三个关键点分别在注释处标出。可以看出即便View是disabled状态，依然不会影响事件的消费，只是它看起来不可用。只要CLICKABLE和LONG_CLICKABLE有一个为true，就一定会消费这个事件，就是onTouchEvent返回true。这点也印证了我们前面说的View 的onTouchEvent 方法默认都会消费掉事件（返回true），除非它是不可点击的（clickable和longClickable同时为false），View的longClickable默认为false，clickable需要区分情况，如Button的clickable默认为true，而TextView的clickable默认为false。 ACTION_UP方法中有performClick()；接下来看一下它：12345678910111213141516171819202122232425/** * Call this view&apos;s OnClickListener, if it is defined. Performs all normal * actions associated with clicking: reporting accessibility event, playing * a sound, etc. * * @return True there was an assigned OnClickListener that was called, false * otherwise is returned. */ public boolean performClick() &#123; final boolean result; final ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnClickListener != null) &#123; playSoundEffect(SoundEffectConstants.CLICK); li.mOnClickListener.onClick(this); result = true; &#125; else &#123; result = false; &#125; sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED); notifyEnterOrExitForAutoFillIfNeeded(true); return result; &#125; 很明显，如果View设置了OnClickListener，那么会回调onClick方法。 最后搞个流程图","comments":true,"tags":[{"name":"Android_View事件分发机制03","slug":"Android-View事件分发机制03","permalink":"/tags/Android-View事件分发机制03/"}]},{"title":"Android_View事件分发机制02","date":"2018-05-31T03:05:17.000Z","path":"2018/05/31/Android-View事件分发机制02/","text":"前言 从上一章节(Activity事件分发机制可知道)，ViewGroup事件分发机制从dispatchTouchEvent()开始。 源码分析(直接、简单) (我用的是API 27的源码) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220@Override public boolean dispatchTouchEvent(MotionEvent ev) &#123; if (mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onTouchEvent(ev, 1); &#125; // If the event targets the accessibility focused view and this is it, start // normal event dispatch. Maybe a descendant is what will handle the click. if (ev.isTargetAccessibilityFocus() &amp;&amp; isAccessibilityFocusedViewOrHost()) &#123; ev.setTargetAccessibilityFocus(false); &#125; boolean handled = false; if (onFilterTouchEventForSecurity(ev)) &#123; final int action = ev.getAction(); final int actionMasked = action &amp; MotionEvent.ACTION_MASK; // Handle an initial down. if (actionMasked == MotionEvent.ACTION_DOWN) &#123; // Throw away all previous state when starting a new touch gesture. // The framework may have dropped the up or cancel event for the previous gesture // due to an app switch, ANR, or some other state change. cancelAndClearTouchTargets(ev); resetTouchState(); &#125; // Check for interception. final boolean intercepted; // 用来标记ViewGroup是否拦截Touch事件的传递。 if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) &#123;// 当事件是按下的时候，或者找到了能够接收touch事件的目标组件 final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) &#123; intercepted = onInterceptTouchEvent(ev); ev.setAction(action); // restore action in case it was changed &#125; else &#123; intercepted = false; &#125; &#125; else &#123; // There are no touch targets and this action is not an initial down // so this view group continues to intercept touches. intercepted = true; &#125; // If intercepted, start normal event dispatch. Also if there is already // a view that is handling the gesture, do normal event dispatch. if (intercepted || mFirstTouchTarget != null) &#123; ev.setTargetAccessibilityFocus(false); &#125; // Check for cancelation. final boolean canceled = resetCancelNextUpFlag(this) || actionMasked == MotionEvent.ACTION_CANCEL; // Update list of touch targets for pointer down, if needed. final boolean split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != 0; TouchTarget newTouchTarget = null; boolean alreadyDispatchedToNewTouchTarget = false; if (!canceled &amp;&amp; !intercepted) &#123;//如果不是ACTION_CANCEL而且不拦截的情况下，遍历ViewGroup的子View。 // If the event is targeting accessiiblity focus we give it to the // view that has accessibility focus and if it does not handle it // we clear the flag and dispatch the event to all children as usual. // We are looking up the accessibility focused host to avoid keeping // state since these events are very rare. View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus() ? findChildWithAccessibilityFocus() : null; if (actionMasked == MotionEvent.ACTION_DOWN || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN) || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123; final int actionIndex = ev.getActionIndex(); // always 0 for down final int idBitsToAssign = split ? 1 &lt;&lt; ev.getPointerId(actionIndex) : TouchTarget.ALL_POINTER_IDS; // Clean up earlier touch targets for this pointer id in case they // have become out of sync. removePointersFromTouchTargets(idBitsToAssign); final int childrenCount = mChildrenCount; if (newTouchTarget == null &amp;&amp; childrenCount != 0) &#123; final float x = ev.getX(actionIndex); final float y = ev.getY(actionIndex); // Find a child that can receive the event. // Scan children from front to back. final ArrayList&lt;View&gt; preorderedList = buildTouchDispatchChildList(); final boolean customOrder = preorderedList == null &amp;&amp; isChildrenDrawingOrderEnabled(); final View[] children = mChildren; for (int i = childrenCount - 1; i &gt;= 0; i--) &#123;// 倒序遍历（为什么是倒序呢？ 因为addView()，后添加的View是放在上面的） final int childIndex = getAndVerifyPreorderedIndex( childrenCount, i, customOrder); final View child = getAndVerifyPreorderedView( preorderedList, children, childIndex); // If there is a view that has accessibility focus we want it // to get the event first and if not handled we will perform a // normal dispatch. We may do a double iteration but this is // safer given the timeframe. if (childWithAccessibilityFocus != null) &#123; if (childWithAccessibilityFocus != child) &#123; continue; &#125; childWithAccessibilityFocus = null; i = childrenCount - 1; &#125; if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) &#123; ev.setTargetAccessibilityFocus(false); //canViewReceivePointerEvents 返回的是 当前view可见或者正在执行动画 //isTransformedTouchPointInView 返回的是触摸点是否在View中 // 过滤掉不可以见的，并且当前触摸的坐标不在子View范围内的子View。 continue; &#125; newTouchTarget = getTouchTarget(child); if (newTouchTarget != null) &#123; // Child is already receiving touch within its bounds. // Give it the new pointer in addition to the ones it is handling. newTouchTarget.pointerIdBits |= idBitsToAssign; break; &#125; resetCancelNextUpFlag(child); if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) &#123; // Child wants to receive touch within its bounds. mLastTouchDownTime = ev.getDownTime(); if (preorderedList != null) &#123; // childIndex points into presorted list, find original index for (int j = 0; j &lt; childrenCount; j++) &#123; if (children[childIndex] == mChildren[j]) &#123; mLastTouchDownIndex = j; break; &#125; &#125; &#125; else &#123; mLastTouchDownIndex = childIndex; &#125; mLastTouchDownX = ev.getX(); mLastTouchDownY = ev.getY(); newTouchTarget = addTouchTarget(child, idBitsToAssign); alreadyDispatchedToNewTouchTarget = true; break; &#125; // The accessibility focus didn&apos;t handle the event, so clear // the flag and do a normal dispatch to all children. ev.setTargetAccessibilityFocus(false); &#125; if (preorderedList != null) preorderedList.clear(); &#125; if (newTouchTarget == null &amp;&amp; mFirstTouchTarget != null) &#123; // Did not find a child to receive the event. // Assign the pointer to the least recently added target. newTouchTarget = mFirstTouchTarget; while (newTouchTarget.next != null) &#123; newTouchTarget = newTouchTarget.next; &#125; newTouchTarget.pointerIdBits |= idBitsToAssign; &#125; &#125; &#125; // Dispatch to touch targets. if (mFirstTouchTarget == null) &#123; // No touch targets so treat this as an ordinary view. handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS); &#125; else &#123; // Dispatch to touch targets, excluding the new touch target if we already // dispatched to it. Cancel touch targets if necessary. TouchTarget predecessor = null; TouchTarget target = mFirstTouchTarget; while (target != null) &#123; final TouchTarget next = target.next; if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123; handled = true; &#125; else &#123; final boolean cancelChild = resetCancelNextUpFlag(target.child) || intercepted; if (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) &#123; handled = true; &#125; if (cancelChild) &#123; if (predecessor == null) &#123; mFirstTouchTarget = next; &#125; else &#123; predecessor.next = next; &#125; target.recycle(); target = next; continue; &#125; &#125; predecessor = target; target = next; &#125; &#125; // Update list of touch targets for pointer up or cancel, if needed. if (canceled || actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123; resetTouchState(); &#125; else if (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_UP) &#123; final int actionIndex = ev.getActionIndex(); final int idBitsToRemove = 1 &lt;&lt; ev.getPointerId(actionIndex); removePointersFromTouchTargets(idBitsToRemove); &#125; &#125; if (!handled &amp;&amp; mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1); &#125; return handled; &#125; 解释一下disallowIntercept 是指是否禁用掉事件拦截的功能。默认都是false。首先判断是否拦截事件。如果没有禁用掉事件拦截的话，就获取onInterceptTouchEvent的返回值；如果禁用掉事件拦截的话，就直接给intercepted 赋值false，表示事件不会被拦截。canceled 赋值的是检查是否取消动作ACTION_CANCEL。 里面调用了dispatchTransformedTouchEvent() 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/** * Transforms a motion event into the coordinate space of a particular child view, * filters out irrelevant pointer ids, and overrides its action if necessary. * If child is null, assumes the MotionEvent will be sent to this ViewGroup instead. */ private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel, View child, int desiredPointerIdBits) &#123; final boolean handled; // Canceling motions is a special case. We don&apos;t need to perform any transformations // or filtering. The important part is the action, not the contents. final int oldAction = event.getAction(); if (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123; event.setAction(MotionEvent.ACTION_CANCEL); if (child == null) &#123; handled = super.dispatchTouchEvent(event); &#125; else &#123; handled = child.dispatchTouchEvent(event); &#125; event.setAction(oldAction); return handled; &#125; // Calculate the number of pointers to deliver. final int oldPointerIdBits = event.getPointerIdBits(); final int newPointerIdBits = oldPointerIdBits &amp; desiredPointerIdBits; // If for some reason we ended up in an inconsistent state where it looks like we // might produce a motion event with no pointers in it, then drop the event. if (newPointerIdBits == 0) &#123; return false; &#125; // If the number of pointers is the same and we don&apos;t need to perform any fancy // irreversible transformations, then we can reuse the motion event for this // dispatch as long as we are careful to revert any changes we make. // Otherwise we need to make a copy. final MotionEvent transformedEvent; if (newPointerIdBits == oldPointerIdBits) &#123; if (child == null || child.hasIdentityMatrix()) &#123; if (child == null) &#123; handled = super.dispatchTouchEvent(event); &#125; else &#123; final float offsetX = mScrollX - child.mLeft; final float offsetY = mScrollY - child.mTop; event.offsetLocation(offsetX, offsetY); handled = child.dispatchTouchEvent(event); event.offsetLocation(-offsetX, -offsetY); &#125; return handled; &#125; transformedEvent = MotionEvent.obtain(event); &#125; else &#123; transformedEvent = event.split(newPointerIdBits); &#125; // Perform any necessary transformations and dispatch. if (child == null) &#123; handled = super.dispatchTouchEvent(transformedEvent); &#125; else &#123; final float offsetX = mScrollX - child.mLeft; final float offsetY = mScrollY - child.mTop; transformedEvent.offsetLocation(offsetX, offsetY); if (! child.hasIdentityMatrix()) &#123; transformedEvent.transform(child.getInverseMatrix()); &#125; handled = child.dispatchTouchEvent(transformedEvent); &#125; // Done. transformedEvent.recycle(); return handled; &#125; 如果传入的子View不=为空的话，就传递给子View中的dispatchTouchEvent方法调用。如果为空，就传递给ViewGroup自身的dispatchTouchEvent()。这里调用的是 super.dispatchTouchEvent(event)，ViewGroup的父类虽然是一个View，但是实际上还是一个ViewGroup，相当于调用自身的dispatchTouchEvent。 流程图 下章节继续讲解View分发事件的源码分析","comments":true,"tags":[{"name":"Android_View事件分发机制02","slug":"Android-View事件分发机制02","permalink":"/tags/Android-View事件分发机制02/"}]},{"title":"Android View事件分发机制01","date":"2018-05-27T07:51:53.000Z","path":"2018/05/27/Android_View事件分发机制01/","text":"前言 从Activity开始分发 当用户触摸屏幕时（View 或 ViewGroup派生的控件），将产生点击事件（Touch事件） Touch事件的相关细节（发生触摸的位置、时间等）被封装成MotionEvent对象 事件类型(4种) 事件类型 具体动作 MotionEvent.ACTION_DOWN 按下View（所有事件的开始) MotionEvent.ACTION_UP 抬起View（与DOWN对应) MotionEvent.ACTION_MOVE 滑动View MotionEvent.ACTION_CANCEL 结束事件（非人为原因) 事件在哪些对象之间进行传递 Activity—&gt;ViewGroup—&gt;View 核心方法 dispatchTouchEvent()—&gt;onInterceptTouchEvent()(备注:这个方法只有ViewGroup有,View和Activity没有)—&gt;onTouchEvent() 源码分析 1234567891011121314151617181920212223242526272829303132333435Activity 源码分析/** * Called to process touch screen events. You can override this to * intercept all touch screen events before they are dispatched to the * window. Be sure to call this implementation for touch screen events * that should be handled normally. * * @param ev The touch screen event. * * @return boolean Return true if this event was consumed. */ public boolean dispatchTouchEvent(MotionEvent ev) &#123; // 一般事件列开始都是DOWN事件 = 按下事件，故此处基本是true if (ev.getAction() == MotionEvent.ACTION_DOWN) &#123; onUserInteraction(); &#125; if (getWindow().superDispatchTouchEvent(ev)) &#123; return true; // 若getWindow().superDispatchTouchEvent(ev)的返回true // 则Activity.dispatchTouchEvent（）就返回true，则方法结束。即 ：该点击事件停止往下传递 &amp; 事件传递过程结束 // 否则：继续往下调用Activity.onTouchEvent &#125; return onTouchEvent(ev); &#125;/** * 分析1：onUserInteraction() * 作用：实现屏保功能 * 注： * a. 该方法为空方法 * b. 当此activity在栈顶时，触屏点击按home，back，menu键等都会触发此方法 */ public void onUserInteraction() &#123; &#125; 接着我们继续看 superDispatchTouchEvent(ev) 方法 这里我在说下窗口机制:主要是由Activity—&gt;PhoneWindow—&gt;DecorView—&gt;ContentView，也就是PhoneWindow通过继承Window抽象类,然后触发这个方法，接着调用DecorView方法,将当前手势传下去，因为DecorView是继承FrameLayout。由于FrameLayout的父类是ViewGroup，DecorView间接=ViewGroup(下一章节会说到) 1234567891011121314/** * 分析2：getWindow().superDispatchTouchEvent(ev) * 说明： * a. getWindow() = 获取Window类的对象 * b. Window类是抽象类，其唯一实现类 = PhoneWindow类；即此处的Window类对象 = PhoneWindow类对象 * c. Window类的superDispatchTouchEvent() = 1个抽象方法，由子类PhoneWindow类实现 */ @Override public boolean superDispatchTouchEvent(MotionEvent event) &#123; return mDecor.superDispatchTouchEvent(event); // mDecor = 顶层View（DecorView）的实例对象 &#125; 流程图 放松一下,图片走起,哈哈哈 。下章节继续讲解ViewGroup事件分发机制","comments":true,"tags":[{"name":"Android View事件分发机制01","slug":"Android-View事件分发机制01","permalink":"/tags/Android-View事件分发机制01/"}]},{"title":"retrofit源码分析","date":"2018-05-06T04:01:29.309Z","path":"2018/05/06/retrofit/","text":"导言retrofit的最大特点就是解耦，要解耦就需要大量的设计模式。假如一点设计模式都不懂的人，可能很难看懂retrofit。~_~ 不要着急, 先上图，压压惊。 首先呢，还是看一下流程图。（如果哪有遗漏，可以私发给我 QQ号:203911607） 主体下面讲解一下主流程: 1.创建一个接口进行HTTP请求描述；2.使用Retrofit.Builder构建模式构造出一个Retrofit实例；3.调用retrofit.create()方法获取请求接口实例；4.由请求接口实例获取到Call对象；进行网络请求（同步/异步）接下来，我们就按照以上正常的网络请求顺序来对Retrofit源码进行解析。 创建一个接口进行HTTP请求描述 public interface ApiService { @GET(“users/{user}/gg”) Call bean(@Path(“user”) String user);}这里主要做的就是采用注解的方式进行HTTP描述，后面在第4步由请求接口实例获取到Call对象时进行反射提取注解内容进行HTTP请求构造（如果开启了预先加载解析（validateEagerly=true），那么在第3步调用retrofit.create()方法获取请求接口实例的时候就会进行注解解析），具体解析方法参考后续分析。 使用Retrofit.Builder构建模式构造出一个Retrofit实例123Retrofit retrofit = new Retrofit.Builder() .baseUrl(\"https://wangshuipo.top/\") .build(); 那我们就先来看下Retrofit.Builder部分源码: 1234567891011121314151617181920/** * Build a new &#123;@link Retrofit&#125;. * Calling &#123;@link #baseUrl&#125; is required before calling &#123;@link #build()&#125;. All other methods * are optional. */ public static final class Builder &#123; private final Platform platform; //callFactory通过newCall(Request request)方法，返回一个okhttp3.Call对象，以便让我们进行实际的HTTP请求 //也就是说callFactory是我们用来生成一个客户端HTTP请求工厂实例 private @Nullable okhttp3.Call.Factory callFactory; private HttpUrl baseUrl; //converterFactories生产Converter&lt;F, T&gt;，用于将HTTP返回结果F类型转换为T类型，或将HTTP请求类型F转换为T。 private final List&lt;Converter.Factory&gt; converterFactories = new ArrayList&lt;&gt;(); //adapterFactories生产 CallAdapter&lt;R, T&gt;，用于将retrofit2.Call&lt;R&gt;网络请求类型转换为T类型：T adapt(Call&lt;R&gt; var1); private final List&lt;CallAdapter.Factory&gt; adapterFactories = new ArrayList&lt;&gt;(); private @Nullable Executor callbackExecutor; private boolean validateEagerly; ···&#125; 从Retrofit.Builder的注释中，我们可以看到，在调用Retrofit.Builder.build()之前，除了baseUrl()是必须配置的以外，其他的内容都是可选配置。这里要对两个类型做下讲解，因为笔者在刚分析Retrofit源码时，被这两个类型的概念弄得头晕眼胀，好在一顿分析后，终于有了一点眉目，这两个类型就是：Converter和CallAdapter。Converter：数据转换器，用来将HTTP请求返回结果由F类型转换为T类型，或者将HTTP请求类型F转换为T123456789public interface Converter&lt;F, T&gt; &#123; T convert(F value) throws IOException; ···&#125;//举例：new Retrofit.Builder() .baseUrl(\"https://wangshuipo.top/\") .addConverterFactory(GsonConverterFactory.create()) .build(); 上面配置了ConverterFactory为GsonConverterFactory，那么当HTTP请求结果返回时，就会由GsonConverterFactory产生的Converter，假设为Converter","comments":true,"tags":[{"name":"retrofit源码分析","slug":"retrofit源码分析","permalink":"/tags/retrofit源码分析/"}]},{"title":"git提交基本命令","date":"2018-04-24T08:03:56.948Z","path":"2018/04/24/gitStyle/","text":"基本命令:1.ls -a 表示使用lunix命令查看文件夹下的文件。 2.git init 表示初始化一个空的git仓库。 3.git status 表示默认生成的仓库里该文件夹里面的文件没有追踪，这个命令可以查看当前状态。 4.git add 文件名 表示添加到暂存区，追踪。 5.git commit -m &apos;可以添加描述&apos; 表示提交文件。 6.git log 表示查看提交信息。 7.git add . 表示可以添加全部文件。 8.git commit -am &apos;可以添加描述&apos; 表示添加并提交文件。 9.git log --oneline 表示只查看描述信息。 git的三层结构1.working directory 工作区 2.staging index 暂存区 3.git directory(Repository)版本库 git中文件四种状态1.untracked:未追踪 2.Modified:表示工作区修改了某个文件但是还没有添加到暂存区 3.Stage:表示把工作区修改的文件添加到暂存区但是没有提交到版本库 4.Committed:表示数据被安全的存储在本地仓库中 git撤销操作1.git commit --amend 撤销上一次提交，并将暂存区的文件重新提交。(注意跳出是先按Esc，然后输入输入:wq再按Enter键) 2.git checkout -- filename 拉取暂存区的文件并将其替换工作区的文件，注意与git checkout branchname区别 3.git reset HEAD -- filename 拉取最近一次提交的版本库中的这个文件到暂存区，该操作不影响工作区。(可以在git log 中选择其中的一个版本号替换HEAD,这么做可以拉回上一次提交的样式。具体写法git reset 选择想要替换回来的一次版本号 filename ) 4.git reset --options 版本号{options可以替换--hard --mixed --soft } git文件删除1.git rm --filename {1.删除工作区及暂存区中的改文件相当于删除文件后执行 git add 2.git rm --cached filename 在不小心将不需要追踪的文件添加到暂存区，想要删除暂存的文件但不想删除工作区的文件很有用(应用场景.gitignore.git远程仓库) 3.git rm -f filename 当工作区或者暂存区文件修改了(防止把修改误删除了) 4.glob模式--星号(*)匹配零个或多个任意字符 --[abc] 匹配任何一个列在方括号中的字符--问号(?)只匹配一个任意字符 --[0-9]、[a-z]匹配范围 } 2.git mv --filename 相当于 {1.mv oldname newname 2.git rm oldname 3.git add newname } git分支1.git 分支的创建、修改、切换、删除{1.git branch 查看分支 2.git branch branchname创建分支 3.git branch -m oldname newname 修改分支名称 4.git checkout [-b] branchname 如果加上-b命令的意思是创建该分支并且切换分支,反之只是切换分支 5.git branch -D branchname删除分支 } 2. git 分支合并 2-1.分值的指南--HEAD指向当前工作的分支--再切换分支时指向新的分支 2-2.git diff{1.git diff 比较工作区与暂存区文件的差异 2.git diff --staged 比较暂存区与版本库的文件差异 3.git diff 版本号 版本号 比较分支内两个版本的差异 4.git diff 分支 分支 比较两个分支的最新提交版本的差异 } 2-3.git merge branchname 合并之前需要先切换到master分支--快速合并和冲突合并 3.存储变更 3-1.git stash 3-2.git stash list 3-3.git stash apply stash@num git stash apply 后面不加名字则应用最近一次存储信息 3-4.git stash drop stash@num git stash apply 只是运用存储信息，并不删除他，drop命令可以删除它 git 远程仓库1.github上的仓库{1.创建仓库 2.clone仓库到本地 3.本地push到仓库 4.pull代码到本地 5.ignoring files } 2.远程服务器上的仓库{1.用taskmanager来演示 2.git init --bare 3.git remote add name path 4.git remote rm name 5.git remote rename oldname newname 6.git fetch } 3.Git ssh免密登录{1.首先要配置username和邮箱 git config --global user.name yinlijun git config user.email aaa@aaa.com如果配置了就不要配置 ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 2.ssh-copy-id user@host 将本机的公钥复制到远程服务器的authorized_keys文件中 3.如果不是自己的服务器可以将本地公钥发给服务器管理员添加在authorized_keys文件后面 4. } Git帮助文档的使用1.git help 2.git help command 3.官方地址---http://git-scm.com/docs http://www.wangshuibo.github.io","comments":true,"tags":[{"name":"git命令","slug":"git命令","permalink":"/tags/git命令/"}]},{"title":"七种基本排序算法的实现和总结","date":"2017-12-10T08:33:18.179Z","path":"2017/12/10/px/","text":"1、冒泡排序123456789101112 原理：每次比较两个相邻的元素，如果它们的顺序错误就把它们交换过来。 步骤：1.1 比较相邻的元素。如果倒数第一个比倒数第二个小，就交换他们两个。 1.2 对第0个到第n-1个数据做同样的工作。这时，最小的数就“浮”到了数组最开始的位置上。 1.3 针对所有的元素重复以上的步骤，除了第一个。 1.4 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。for (int i = 0; i &lt; arr.length; i++) &#123; for (int j = arr.length - 1; j &gt; i; j--) &#123; if (arr[j] &lt; arr[j - 1]) &#123; SortUtil.swap(arr, j, j - 1); &#125; &#125;&#125; 2、选择排序12345678910111213 原理：不断地选择剩余元素中的最小者 步骤：2.1 找到数组中最小元素的下标，将第一个元素与最小元素下标的数进行交换。 2.2 在剩下的元素中找到最小元素下标并将其与数组第二个元素交换，直至整个数组排序。for (int i = 0; i &lt; arr.length; i++) &#123; int minIndex = i; for (int j = i + 1; j &lt; arr.length; j++) &#123; if (arr[j] &lt; arr[minIndex]) &#123; minIndex = j; &#125; &#125; SortUtil.swap(arr, minIndex, i);&#125; 3、插入排序123456789101112131415 原理：插入排序的工作原理是，对于每个未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。 步骤：3.1 从第一个元素开始，该元素可以认为已经被排序 3.2 取出下一个元素，在已经排序的元素序列中从后向前扫描 3.3 如果被扫描的元素（已排序）大于新元素，将该元素后移一位 3.4 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置 3.5 将新元素插入到该位置后 3.6 重复步骤2~5for (int i = 1; i &lt; arr.length; i++) &#123; int temp = arr[i]; int j; for (j = i; j &gt; 0 &amp;&amp; (arr[j - 1] &gt; temp); j--) &#123; arr[j] = arr[j -1]; &#125; arr[j] = temp;&#125; 4、归并排序12345678910111213141516171819202122232425262728293031323334 原理：将长度为n的记录不断划分，划分到长度为1时，再两两合并，依次递归。主要是利用分治法来处理。@Overridepublic int[] sort(int[] arr) &#123; mergeSort(arr, 0, arr.length - 1); return arr;&#125;private void mergeSort(int[] array, int start, int end) &#123; if (start &gt;= end) return; int middle = (start + end) / 2; mergeSort(array, start, middle); mergeSort(array, middle + 1, end); merge(array, start, middle, end);&#125;private void merge(int[] array, int start, int middle, int end) &#123; int[] aux = new int[end - start + 1]; System.arraycopy(array, start, aux, 0, end - start + 1); int left = start; int right = middle + 1; for (int k = start; k &lt;= end; k++) &#123; if (left &gt; middle) &#123; array[k] = aux[right - start]; right++; &#125; else if (right &gt; end) &#123; array[k] = aux[left - start]; left++; &#125; else if (aux[left - start] &gt; aux[right - start]) &#123; array[k] = aux[right - start]; right++; &#125; else &#123; array[k] = aux[left - start]; left++; &#125; &#125;&#125; 5、堆排序12345678910111213141516171819202122232425262728293031 原理：堆排序就是利用堆进行排序的方法.基本思想是:将待排序的序列构造成一个大顶堆.此时,整个序列的最大值就是堆顶的根结点.将它移走(其实就是将其与堆数组的末尾元素交换,此时末尾元素就是最大值),然后将剩余的n-1个序列重新构造成一个堆,这样就会得到n个元素的次大值.如此反复执行,便能得到一个有序序列了。 步骤：5.1 构造最大堆（Build_Max_Heap）：若数组下标范围为0~n，考虑到单独一个元素是大根堆，则从下标n/2开始的元素均为大根堆。于是只要从n/2-1开始，向前依次构造大根堆，这样就能保证，构造到某个节点时，它的左右子树都已经是大根堆。5.2 堆排序（HeapSort）：由于堆是用数组模拟的。得到一个大根堆后，数组内部并不是有序的。因此需要将堆化数组有序化。思想是移除根节点，并做最大堆调整的递归运算。第一次将heap[0]与heap[n-1]交换，再对heap[0...n-2]做最大堆调整。第二次将heap[0]与heap[n-2]交换，再对heap[0...n-3]做最大堆调整。重复该操作直至heap[0]和heap[1]交换。由于每次都是将最大的数并入到后面的有序区间，故操作完后整个数组就是有序的了。 5.3 最大堆调整（Max_Heapify）：该方法是提供给上述两个过程调用的。目的是将堆的末端子节点作调整，使得子节点永远小于父节点 。public int[] sort(int[] arr) &#123; int len = arr.length - 1; for (int i = len / 2 - 1; i &gt;= 0; i--) &#123; headAdjust(arr, i, len); &#125; while (len &gt;= 0) &#123; SortUtil.swap(arr, 0, len--); headAdjust(arr, 0, len); &#125; return arr;&#125;private void headAdjust(int[] arr, int parent, int len) &#123; int leftChild, rightChild, maxChild; while ((leftChild = 2 * parent + 1) &lt;= len) &#123; rightChild = leftChild + 1; maxChild = leftChild; // 将maxChild指向左右子节点中的较大者 if (maxChild &lt; len &amp;&amp; (arr[leftChild] &lt; arr[rightChild])) &#123; maxChild++; &#125; if (arr[parent] &lt; arr[maxChild]) &#123; SortUtil.swap(arr, parent, maxChild); parent = maxChild; &#125; else &#123; break; &#125; &#125;&#125; 6、希尔排序123456789101112131415 原理：先将整个待排元素序列分割成若干子序列（由相隔某个“增量”的元素组成的）分别进行直接插入排序，然后依次缩减增量再进行排序，待整个序列中的元素基本有序（增量足够小）时，再对全体元素进行一次直接插入排序（增量为1）。其时间复杂度为O( n^3/2 ),要好于直接插入排序的O(n^2)int gap = arr.length / 2;while (gap &gt;= 1) &#123; for (int i = gap; i &lt; arr.length; i++) &#123; int temp = arr[i]; int j = i - gap; while (j &gt;= 0 &amp;&amp; arr[j] &gt; temp) &#123; arr[j + gap] = arr[j]; j -= gap; &#125; arr[j + gap] = temp; &#125; gap /= 2;&#125; 7、快速排序1234567891011121314151617181920212223 原理：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。 步骤：7.1 从数列中挑出一个元素作为基准数。 7.2 分区过程，将比基准数大的放到右边，小于或等于它的数都放到左边。 7.3 再对左右区间递归执行第二步，直至各区间只有一个数。private void quickSort(int[] arr, int left, int right) &#123; if (left &gt;= right) return; int i = left, j = right, temp = arr[left]; while (i &lt; j) &#123; while (i &lt; j &amp;&amp; arr[j] &gt;= temp) &#123; j--; &#125; while (i &lt; j &amp;&amp; arr[i] &lt;= temp) &#123; i++; &#125; if (i &lt; j) &#123; SortUtil.swap(arr, i, j); &#125; &#125; arr[left] = arr[i]; arr[i] = temp; quickSort(arr, left, i - 1); quickSort(arr, i + 1, right);&#125;","comments":true,"tags":[{"name":"排序","slug":"排序","permalink":"/tags/排序/"}]}]